// generated by ModelGongFileTemplate
package models

import "sort"

// swagger:ignore
type __void struct{}

// needed for creating set of instances in the stage
var __member __void

// StageStruct enables storage of staged instances
// swagger:ignore
type StageStruct struct { // insertion point for definition of arrays registering instances
	VisualCenters           map[*VisualCenter]struct{}
	VisualCenters_mapString map[string]*VisualCenter

	VisualCircles           map[*VisualCircle]struct{}
	VisualCircles_mapString map[string]*VisualCircle

	VisualIcons           map[*VisualIcon]struct{}
	VisualIcons_mapString map[string]*VisualIcon

	VisualLayers           map[*VisualLayer]struct{}
	VisualLayers_mapString map[string]*VisualLayer

	VisualLines           map[*VisualLine]struct{}
	VisualLines_mapString map[string]*VisualLine

	VisualMaps           map[*VisualMap]struct{}
	VisualMaps_mapString map[string]*VisualMap

	VisualTracks           map[*VisualTrack]struct{}
	VisualTracks_mapString map[string]*VisualTrack

	AllModelsStructCreateCallback AllModelsStructCreateInterface

	AllModelsStructDeleteCallback AllModelsStructDeleteInterface

	BackRepo BackRepoInterface

	// if set will be called before each commit to the back repo
	OnInitCommitCallback OnInitCommitInterface
}

type OnInitCommitInterface interface {
	BeforeCommit(stage *StageStruct)
}

type BackRepoInterface interface {
	Commit(stage *StageStruct)
	Checkout(stage *StageStruct)
	Backup(stage *StageStruct, dirPath string)
	Restore(stage *StageStruct, dirPath string)
	BackupXL(stage *StageStruct, dirPath string)
	RestoreXL(stage *StageStruct, dirPath string)
	// insertion point for Commit and Checkout signatures
	CommitVisualCenter(visualcenter *VisualCenter)
	CheckoutVisualCenter(visualcenter *VisualCenter)
	CommitVisualCircle(visualcircle *VisualCircle)
	CheckoutVisualCircle(visualcircle *VisualCircle)
	CommitVisualIcon(visualicon *VisualIcon)
	CheckoutVisualIcon(visualicon *VisualIcon)
	CommitVisualLayer(visuallayer *VisualLayer)
	CheckoutVisualLayer(visuallayer *VisualLayer)
	CommitVisualLine(visualline *VisualLine)
	CheckoutVisualLine(visualline *VisualLine)
	CommitVisualMap(visualmap *VisualMap)
	CheckoutVisualMap(visualmap *VisualMap)
	CommitVisualTrack(visualtrack *VisualTrack)
	CheckoutVisualTrack(visualtrack *VisualTrack)
	GetLastCommitNb() uint
	GetLastPushFromFrontNb() uint
}

// swagger:ignore instructs the gong compiler (gongc) to avoid this particular struct
var Stage StageStruct = StageStruct{ // insertion point for array initiatialisation
	VisualCenters:           make(map[*VisualCenter]struct{}),
	VisualCenters_mapString: make(map[string]*VisualCenter),

	VisualCircles:           make(map[*VisualCircle]struct{}),
	VisualCircles_mapString: make(map[string]*VisualCircle),

	VisualIcons:           make(map[*VisualIcon]struct{}),
	VisualIcons_mapString: make(map[string]*VisualIcon),

	VisualLayers:           make(map[*VisualLayer]struct{}),
	VisualLayers_mapString: make(map[string]*VisualLayer),

	VisualLines:           make(map[*VisualLine]struct{}),
	VisualLines_mapString: make(map[string]*VisualLine),

	VisualMaps:           make(map[*VisualMap]struct{}),
	VisualMaps_mapString: make(map[string]*VisualMap),

	VisualTracks:           make(map[*VisualTrack]struct{}),
	VisualTracks_mapString: make(map[string]*VisualTrack),

	// end of insertion point
}

func (stage *StageStruct) Commit() {
	if stage.BackRepo != nil {
		stage.BackRepo.Commit(stage)
	}
}

func (stage *StageStruct) Checkout() {
	if stage.BackRepo != nil {
		stage.BackRepo.Checkout(stage)
	}
}

// backup generates backup files in the dirPath
func (stage *StageStruct) Backup(dirPath string) {
	if stage.BackRepo != nil {
		stage.BackRepo.Backup(stage, dirPath)
	}
}

// Restore resets Stage & BackRepo and restores their content from the restore files in dirPath
func (stage *StageStruct) Restore(dirPath string) {
	if stage.BackRepo != nil {
		stage.BackRepo.Restore(stage, dirPath)
	}
}

// backup generates backup files in the dirPath
func (stage *StageStruct) BackupXL(dirPath string) {
	if stage.BackRepo != nil {
		stage.BackRepo.BackupXL(stage, dirPath)
	}
}

// Restore resets Stage & BackRepo and restores their content from the restore files in dirPath
func (stage *StageStruct) RestoreXL(dirPath string) {
	if stage.BackRepo != nil {
		stage.BackRepo.RestoreXL(stage, dirPath)
	}
}

// insertion point for cumulative sub template with model space calls
func (stage *StageStruct) getVisualCenterOrderedStructWithNameField() []*VisualCenter {
	// have alphabetical order generation
	visualcenterOrdered := []*VisualCenter{}
	for visualcenter := range stage.VisualCenters {
		visualcenterOrdered = append(visualcenterOrdered, visualcenter)
	}
	sort.Slice(visualcenterOrdered[:], func(i, j int) bool {
		return visualcenterOrdered[i].Name < visualcenterOrdered[j].Name
	})
	return visualcenterOrdered
}

// Stage puts visualcenter to the model stage
func (visualcenter *VisualCenter) Stage() *VisualCenter {
	Stage.VisualCenters[visualcenter] = __member
	Stage.VisualCenters_mapString[visualcenter.Name] = visualcenter

	return visualcenter
}

// Unstage removes visualcenter off the model stage
func (visualcenter *VisualCenter) Unstage() *VisualCenter {
	delete(Stage.VisualCenters, visualcenter)
	delete(Stage.VisualCenters_mapString, visualcenter.Name)
	return visualcenter
}

// commit visualcenter to the back repo (if it is already staged)
func (visualcenter *VisualCenter) Commit() *VisualCenter {
	if _, ok := Stage.VisualCenters[visualcenter]; ok {
		if Stage.BackRepo != nil {
			Stage.BackRepo.CommitVisualCenter(visualcenter)
		}
	}
	return visualcenter
}

// Checkout visualcenter to the back repo (if it is already staged)
func (visualcenter *VisualCenter) Checkout() *VisualCenter {
	if _, ok := Stage.VisualCenters[visualcenter]; ok {
		if Stage.BackRepo != nil {
			Stage.BackRepo.CheckoutVisualCenter(visualcenter)
		}
	}
	return visualcenter
}

//
// Legacy, to be deleted
//

// StageCopy appends a copy of visualcenter to the model stage
func (visualcenter *VisualCenter) StageCopy() *VisualCenter {
	_visualcenter := new(VisualCenter)
	*_visualcenter = *visualcenter
	_visualcenter.Stage()
	return _visualcenter
}

// StageAndCommit appends visualcenter to the model stage and commit to the orm repo
func (visualcenter *VisualCenter) StageAndCommit() *VisualCenter {
	visualcenter.Stage()
	if Stage.AllModelsStructCreateCallback != nil {
		Stage.AllModelsStructCreateCallback.CreateORMVisualCenter(visualcenter)
	}
	return visualcenter
}

// DeleteStageAndCommit appends visualcenter to the model stage and commit to the orm repo
func (visualcenter *VisualCenter) DeleteStageAndCommit() *VisualCenter {
	visualcenter.Unstage()
	DeleteORMVisualCenter(visualcenter)
	return visualcenter
}

// StageCopyAndCommit appends a copy of visualcenter to the model stage and commit to the orm repo
func (visualcenter *VisualCenter) StageCopyAndCommit() *VisualCenter {
	_visualcenter := new(VisualCenter)
	*_visualcenter = *visualcenter
	_visualcenter.Stage()
	if Stage.AllModelsStructCreateCallback != nil {
		Stage.AllModelsStructCreateCallback.CreateORMVisualCenter(visualcenter)
	}
	return _visualcenter
}

// CreateORMVisualCenter enables dynamic staging of a VisualCenter instance
func CreateORMVisualCenter(visualcenter *VisualCenter) {
	visualcenter.Stage()
	if Stage.AllModelsStructCreateCallback != nil {
		Stage.AllModelsStructCreateCallback.CreateORMVisualCenter(visualcenter)
	}
}

// DeleteORMVisualCenter enables dynamic staging of a VisualCenter instance
func DeleteORMVisualCenter(visualcenter *VisualCenter) {
	visualcenter.Unstage()
	if Stage.AllModelsStructDeleteCallback != nil {
		Stage.AllModelsStructDeleteCallback.DeleteORMVisualCenter(visualcenter)
	}
}

func (stage *StageStruct) getVisualCircleOrderedStructWithNameField() []*VisualCircle {
	// have alphabetical order generation
	visualcircleOrdered := []*VisualCircle{}
	for visualcircle := range stage.VisualCircles {
		visualcircleOrdered = append(visualcircleOrdered, visualcircle)
	}
	sort.Slice(visualcircleOrdered[:], func(i, j int) bool {
		return visualcircleOrdered[i].Name < visualcircleOrdered[j].Name
	})
	return visualcircleOrdered
}

// Stage puts visualcircle to the model stage
func (visualcircle *VisualCircle) Stage() *VisualCircle {
	Stage.VisualCircles[visualcircle] = __member
	Stage.VisualCircles_mapString[visualcircle.Name] = visualcircle

	return visualcircle
}

// Unstage removes visualcircle off the model stage
func (visualcircle *VisualCircle) Unstage() *VisualCircle {
	delete(Stage.VisualCircles, visualcircle)
	delete(Stage.VisualCircles_mapString, visualcircle.Name)
	return visualcircle
}

// commit visualcircle to the back repo (if it is already staged)
func (visualcircle *VisualCircle) Commit() *VisualCircle {
	if _, ok := Stage.VisualCircles[visualcircle]; ok {
		if Stage.BackRepo != nil {
			Stage.BackRepo.CommitVisualCircle(visualcircle)
		}
	}
	return visualcircle
}

// Checkout visualcircle to the back repo (if it is already staged)
func (visualcircle *VisualCircle) Checkout() *VisualCircle {
	if _, ok := Stage.VisualCircles[visualcircle]; ok {
		if Stage.BackRepo != nil {
			Stage.BackRepo.CheckoutVisualCircle(visualcircle)
		}
	}
	return visualcircle
}

//
// Legacy, to be deleted
//

// StageCopy appends a copy of visualcircle to the model stage
func (visualcircle *VisualCircle) StageCopy() *VisualCircle {
	_visualcircle := new(VisualCircle)
	*_visualcircle = *visualcircle
	_visualcircle.Stage()
	return _visualcircle
}

// StageAndCommit appends visualcircle to the model stage and commit to the orm repo
func (visualcircle *VisualCircle) StageAndCommit() *VisualCircle {
	visualcircle.Stage()
	if Stage.AllModelsStructCreateCallback != nil {
		Stage.AllModelsStructCreateCallback.CreateORMVisualCircle(visualcircle)
	}
	return visualcircle
}

// DeleteStageAndCommit appends visualcircle to the model stage and commit to the orm repo
func (visualcircle *VisualCircle) DeleteStageAndCommit() *VisualCircle {
	visualcircle.Unstage()
	DeleteORMVisualCircle(visualcircle)
	return visualcircle
}

// StageCopyAndCommit appends a copy of visualcircle to the model stage and commit to the orm repo
func (visualcircle *VisualCircle) StageCopyAndCommit() *VisualCircle {
	_visualcircle := new(VisualCircle)
	*_visualcircle = *visualcircle
	_visualcircle.Stage()
	if Stage.AllModelsStructCreateCallback != nil {
		Stage.AllModelsStructCreateCallback.CreateORMVisualCircle(visualcircle)
	}
	return _visualcircle
}

// CreateORMVisualCircle enables dynamic staging of a VisualCircle instance
func CreateORMVisualCircle(visualcircle *VisualCircle) {
	visualcircle.Stage()
	if Stage.AllModelsStructCreateCallback != nil {
		Stage.AllModelsStructCreateCallback.CreateORMVisualCircle(visualcircle)
	}
}

// DeleteORMVisualCircle enables dynamic staging of a VisualCircle instance
func DeleteORMVisualCircle(visualcircle *VisualCircle) {
	visualcircle.Unstage()
	if Stage.AllModelsStructDeleteCallback != nil {
		Stage.AllModelsStructDeleteCallback.DeleteORMVisualCircle(visualcircle)
	}
}

func (stage *StageStruct) getVisualIconOrderedStructWithNameField() []*VisualIcon {
	// have alphabetical order generation
	visualiconOrdered := []*VisualIcon{}
	for visualicon := range stage.VisualIcons {
		visualiconOrdered = append(visualiconOrdered, visualicon)
	}
	sort.Slice(visualiconOrdered[:], func(i, j int) bool {
		return visualiconOrdered[i].Name < visualiconOrdered[j].Name
	})
	return visualiconOrdered
}

// Stage puts visualicon to the model stage
func (visualicon *VisualIcon) Stage() *VisualIcon {
	Stage.VisualIcons[visualicon] = __member
	Stage.VisualIcons_mapString[visualicon.Name] = visualicon

	return visualicon
}

// Unstage removes visualicon off the model stage
func (visualicon *VisualIcon) Unstage() *VisualIcon {
	delete(Stage.VisualIcons, visualicon)
	delete(Stage.VisualIcons_mapString, visualicon.Name)
	return visualicon
}

// commit visualicon to the back repo (if it is already staged)
func (visualicon *VisualIcon) Commit() *VisualIcon {
	if _, ok := Stage.VisualIcons[visualicon]; ok {
		if Stage.BackRepo != nil {
			Stage.BackRepo.CommitVisualIcon(visualicon)
		}
	}
	return visualicon
}

// Checkout visualicon to the back repo (if it is already staged)
func (visualicon *VisualIcon) Checkout() *VisualIcon {
	if _, ok := Stage.VisualIcons[visualicon]; ok {
		if Stage.BackRepo != nil {
			Stage.BackRepo.CheckoutVisualIcon(visualicon)
		}
	}
	return visualicon
}

//
// Legacy, to be deleted
//

// StageCopy appends a copy of visualicon to the model stage
func (visualicon *VisualIcon) StageCopy() *VisualIcon {
	_visualicon := new(VisualIcon)
	*_visualicon = *visualicon
	_visualicon.Stage()
	return _visualicon
}

// StageAndCommit appends visualicon to the model stage and commit to the orm repo
func (visualicon *VisualIcon) StageAndCommit() *VisualIcon {
	visualicon.Stage()
	if Stage.AllModelsStructCreateCallback != nil {
		Stage.AllModelsStructCreateCallback.CreateORMVisualIcon(visualicon)
	}
	return visualicon
}

// DeleteStageAndCommit appends visualicon to the model stage and commit to the orm repo
func (visualicon *VisualIcon) DeleteStageAndCommit() *VisualIcon {
	visualicon.Unstage()
	DeleteORMVisualIcon(visualicon)
	return visualicon
}

// StageCopyAndCommit appends a copy of visualicon to the model stage and commit to the orm repo
func (visualicon *VisualIcon) StageCopyAndCommit() *VisualIcon {
	_visualicon := new(VisualIcon)
	*_visualicon = *visualicon
	_visualicon.Stage()
	if Stage.AllModelsStructCreateCallback != nil {
		Stage.AllModelsStructCreateCallback.CreateORMVisualIcon(visualicon)
	}
	return _visualicon
}

// CreateORMVisualIcon enables dynamic staging of a VisualIcon instance
func CreateORMVisualIcon(visualicon *VisualIcon) {
	visualicon.Stage()
	if Stage.AllModelsStructCreateCallback != nil {
		Stage.AllModelsStructCreateCallback.CreateORMVisualIcon(visualicon)
	}
}

// DeleteORMVisualIcon enables dynamic staging of a VisualIcon instance
func DeleteORMVisualIcon(visualicon *VisualIcon) {
	visualicon.Unstage()
	if Stage.AllModelsStructDeleteCallback != nil {
		Stage.AllModelsStructDeleteCallback.DeleteORMVisualIcon(visualicon)
	}
}

func (stage *StageStruct) getVisualLayerOrderedStructWithNameField() []*VisualLayer {
	// have alphabetical order generation
	visuallayerOrdered := []*VisualLayer{}
	for visuallayer := range stage.VisualLayers {
		visuallayerOrdered = append(visuallayerOrdered, visuallayer)
	}
	sort.Slice(visuallayerOrdered[:], func(i, j int) bool {
		return visuallayerOrdered[i].Name < visuallayerOrdered[j].Name
	})
	return visuallayerOrdered
}

// Stage puts visuallayer to the model stage
func (visuallayer *VisualLayer) Stage() *VisualLayer {
	Stage.VisualLayers[visuallayer] = __member
	Stage.VisualLayers_mapString[visuallayer.Name] = visuallayer

	return visuallayer
}

// Unstage removes visuallayer off the model stage
func (visuallayer *VisualLayer) Unstage() *VisualLayer {
	delete(Stage.VisualLayers, visuallayer)
	delete(Stage.VisualLayers_mapString, visuallayer.Name)
	return visuallayer
}

// commit visuallayer to the back repo (if it is already staged)
func (visuallayer *VisualLayer) Commit() *VisualLayer {
	if _, ok := Stage.VisualLayers[visuallayer]; ok {
		if Stage.BackRepo != nil {
			Stage.BackRepo.CommitVisualLayer(visuallayer)
		}
	}
	return visuallayer
}

// Checkout visuallayer to the back repo (if it is already staged)
func (visuallayer *VisualLayer) Checkout() *VisualLayer {
	if _, ok := Stage.VisualLayers[visuallayer]; ok {
		if Stage.BackRepo != nil {
			Stage.BackRepo.CheckoutVisualLayer(visuallayer)
		}
	}
	return visuallayer
}

//
// Legacy, to be deleted
//

// StageCopy appends a copy of visuallayer to the model stage
func (visuallayer *VisualLayer) StageCopy() *VisualLayer {
	_visuallayer := new(VisualLayer)
	*_visuallayer = *visuallayer
	_visuallayer.Stage()
	return _visuallayer
}

// StageAndCommit appends visuallayer to the model stage and commit to the orm repo
func (visuallayer *VisualLayer) StageAndCommit() *VisualLayer {
	visuallayer.Stage()
	if Stage.AllModelsStructCreateCallback != nil {
		Stage.AllModelsStructCreateCallback.CreateORMVisualLayer(visuallayer)
	}
	return visuallayer
}

// DeleteStageAndCommit appends visuallayer to the model stage and commit to the orm repo
func (visuallayer *VisualLayer) DeleteStageAndCommit() *VisualLayer {
	visuallayer.Unstage()
	DeleteORMVisualLayer(visuallayer)
	return visuallayer
}

// StageCopyAndCommit appends a copy of visuallayer to the model stage and commit to the orm repo
func (visuallayer *VisualLayer) StageCopyAndCommit() *VisualLayer {
	_visuallayer := new(VisualLayer)
	*_visuallayer = *visuallayer
	_visuallayer.Stage()
	if Stage.AllModelsStructCreateCallback != nil {
		Stage.AllModelsStructCreateCallback.CreateORMVisualLayer(visuallayer)
	}
	return _visuallayer
}

// CreateORMVisualLayer enables dynamic staging of a VisualLayer instance
func CreateORMVisualLayer(visuallayer *VisualLayer) {
	visuallayer.Stage()
	if Stage.AllModelsStructCreateCallback != nil {
		Stage.AllModelsStructCreateCallback.CreateORMVisualLayer(visuallayer)
	}
}

// DeleteORMVisualLayer enables dynamic staging of a VisualLayer instance
func DeleteORMVisualLayer(visuallayer *VisualLayer) {
	visuallayer.Unstage()
	if Stage.AllModelsStructDeleteCallback != nil {
		Stage.AllModelsStructDeleteCallback.DeleteORMVisualLayer(visuallayer)
	}
}

func (stage *StageStruct) getVisualLineOrderedStructWithNameField() []*VisualLine {
	// have alphabetical order generation
	visuallineOrdered := []*VisualLine{}
	for visualline := range stage.VisualLines {
		visuallineOrdered = append(visuallineOrdered, visualline)
	}
	sort.Slice(visuallineOrdered[:], func(i, j int) bool {
		return visuallineOrdered[i].Name < visuallineOrdered[j].Name
	})
	return visuallineOrdered
}

// Stage puts visualline to the model stage
func (visualline *VisualLine) Stage() *VisualLine {
	Stage.VisualLines[visualline] = __member
	Stage.VisualLines_mapString[visualline.Name] = visualline

	return visualline
}

// Unstage removes visualline off the model stage
func (visualline *VisualLine) Unstage() *VisualLine {
	delete(Stage.VisualLines, visualline)
	delete(Stage.VisualLines_mapString, visualline.Name)
	return visualline
}

// commit visualline to the back repo (if it is already staged)
func (visualline *VisualLine) Commit() *VisualLine {
	if _, ok := Stage.VisualLines[visualline]; ok {
		if Stage.BackRepo != nil {
			Stage.BackRepo.CommitVisualLine(visualline)
		}
	}
	return visualline
}

// Checkout visualline to the back repo (if it is already staged)
func (visualline *VisualLine) Checkout() *VisualLine {
	if _, ok := Stage.VisualLines[visualline]; ok {
		if Stage.BackRepo != nil {
			Stage.BackRepo.CheckoutVisualLine(visualline)
		}
	}
	return visualline
}

//
// Legacy, to be deleted
//

// StageCopy appends a copy of visualline to the model stage
func (visualline *VisualLine) StageCopy() *VisualLine {
	_visualline := new(VisualLine)
	*_visualline = *visualline
	_visualline.Stage()
	return _visualline
}

// StageAndCommit appends visualline to the model stage and commit to the orm repo
func (visualline *VisualLine) StageAndCommit() *VisualLine {
	visualline.Stage()
	if Stage.AllModelsStructCreateCallback != nil {
		Stage.AllModelsStructCreateCallback.CreateORMVisualLine(visualline)
	}
	return visualline
}

// DeleteStageAndCommit appends visualline to the model stage and commit to the orm repo
func (visualline *VisualLine) DeleteStageAndCommit() *VisualLine {
	visualline.Unstage()
	DeleteORMVisualLine(visualline)
	return visualline
}

// StageCopyAndCommit appends a copy of visualline to the model stage and commit to the orm repo
func (visualline *VisualLine) StageCopyAndCommit() *VisualLine {
	_visualline := new(VisualLine)
	*_visualline = *visualline
	_visualline.Stage()
	if Stage.AllModelsStructCreateCallback != nil {
		Stage.AllModelsStructCreateCallback.CreateORMVisualLine(visualline)
	}
	return _visualline
}

// CreateORMVisualLine enables dynamic staging of a VisualLine instance
func CreateORMVisualLine(visualline *VisualLine) {
	visualline.Stage()
	if Stage.AllModelsStructCreateCallback != nil {
		Stage.AllModelsStructCreateCallback.CreateORMVisualLine(visualline)
	}
}

// DeleteORMVisualLine enables dynamic staging of a VisualLine instance
func DeleteORMVisualLine(visualline *VisualLine) {
	visualline.Unstage()
	if Stage.AllModelsStructDeleteCallback != nil {
		Stage.AllModelsStructDeleteCallback.DeleteORMVisualLine(visualline)
	}
}

func (stage *StageStruct) getVisualMapOrderedStructWithNameField() []*VisualMap {
	// have alphabetical order generation
	visualmapOrdered := []*VisualMap{}
	for visualmap := range stage.VisualMaps {
		visualmapOrdered = append(visualmapOrdered, visualmap)
	}
	sort.Slice(visualmapOrdered[:], func(i, j int) bool {
		return visualmapOrdered[i].Name < visualmapOrdered[j].Name
	})
	return visualmapOrdered
}

// Stage puts visualmap to the model stage
func (visualmap *VisualMap) Stage() *VisualMap {
	Stage.VisualMaps[visualmap] = __member
	Stage.VisualMaps_mapString[visualmap.Name] = visualmap

	return visualmap
}

// Unstage removes visualmap off the model stage
func (visualmap *VisualMap) Unstage() *VisualMap {
	delete(Stage.VisualMaps, visualmap)
	delete(Stage.VisualMaps_mapString, visualmap.Name)
	return visualmap
}

// commit visualmap to the back repo (if it is already staged)
func (visualmap *VisualMap) Commit() *VisualMap {
	if _, ok := Stage.VisualMaps[visualmap]; ok {
		if Stage.BackRepo != nil {
			Stage.BackRepo.CommitVisualMap(visualmap)
		}
	}
	return visualmap
}

// Checkout visualmap to the back repo (if it is already staged)
func (visualmap *VisualMap) Checkout() *VisualMap {
	if _, ok := Stage.VisualMaps[visualmap]; ok {
		if Stage.BackRepo != nil {
			Stage.BackRepo.CheckoutVisualMap(visualmap)
		}
	}
	return visualmap
}

//
// Legacy, to be deleted
//

// StageCopy appends a copy of visualmap to the model stage
func (visualmap *VisualMap) StageCopy() *VisualMap {
	_visualmap := new(VisualMap)
	*_visualmap = *visualmap
	_visualmap.Stage()
	return _visualmap
}

// StageAndCommit appends visualmap to the model stage and commit to the orm repo
func (visualmap *VisualMap) StageAndCommit() *VisualMap {
	visualmap.Stage()
	if Stage.AllModelsStructCreateCallback != nil {
		Stage.AllModelsStructCreateCallback.CreateORMVisualMap(visualmap)
	}
	return visualmap
}

// DeleteStageAndCommit appends visualmap to the model stage and commit to the orm repo
func (visualmap *VisualMap) DeleteStageAndCommit() *VisualMap {
	visualmap.Unstage()
	DeleteORMVisualMap(visualmap)
	return visualmap
}

// StageCopyAndCommit appends a copy of visualmap to the model stage and commit to the orm repo
func (visualmap *VisualMap) StageCopyAndCommit() *VisualMap {
	_visualmap := new(VisualMap)
	*_visualmap = *visualmap
	_visualmap.Stage()
	if Stage.AllModelsStructCreateCallback != nil {
		Stage.AllModelsStructCreateCallback.CreateORMVisualMap(visualmap)
	}
	return _visualmap
}

// CreateORMVisualMap enables dynamic staging of a VisualMap instance
func CreateORMVisualMap(visualmap *VisualMap) {
	visualmap.Stage()
	if Stage.AllModelsStructCreateCallback != nil {
		Stage.AllModelsStructCreateCallback.CreateORMVisualMap(visualmap)
	}
}

// DeleteORMVisualMap enables dynamic staging of a VisualMap instance
func DeleteORMVisualMap(visualmap *VisualMap) {
	visualmap.Unstage()
	if Stage.AllModelsStructDeleteCallback != nil {
		Stage.AllModelsStructDeleteCallback.DeleteORMVisualMap(visualmap)
	}
}

func (stage *StageStruct) getVisualTrackOrderedStructWithNameField() []*VisualTrack {
	// have alphabetical order generation
	visualtrackOrdered := []*VisualTrack{}
	for visualtrack := range stage.VisualTracks {
		visualtrackOrdered = append(visualtrackOrdered, visualtrack)
	}
	sort.Slice(visualtrackOrdered[:], func(i, j int) bool {
		return visualtrackOrdered[i].Name < visualtrackOrdered[j].Name
	})
	return visualtrackOrdered
}

// Stage puts visualtrack to the model stage
func (visualtrack *VisualTrack) Stage() *VisualTrack {
	Stage.VisualTracks[visualtrack] = __member
	Stage.VisualTracks_mapString[visualtrack.Name] = visualtrack

	return visualtrack
}

// Unstage removes visualtrack off the model stage
func (visualtrack *VisualTrack) Unstage() *VisualTrack {
	delete(Stage.VisualTracks, visualtrack)
	delete(Stage.VisualTracks_mapString, visualtrack.Name)
	return visualtrack
}

// commit visualtrack to the back repo (if it is already staged)
func (visualtrack *VisualTrack) Commit() *VisualTrack {
	if _, ok := Stage.VisualTracks[visualtrack]; ok {
		if Stage.BackRepo != nil {
			Stage.BackRepo.CommitVisualTrack(visualtrack)
		}
	}
	return visualtrack
}

// Checkout visualtrack to the back repo (if it is already staged)
func (visualtrack *VisualTrack) Checkout() *VisualTrack {
	if _, ok := Stage.VisualTracks[visualtrack]; ok {
		if Stage.BackRepo != nil {
			Stage.BackRepo.CheckoutVisualTrack(visualtrack)
		}
	}
	return visualtrack
}

//
// Legacy, to be deleted
//

// StageCopy appends a copy of visualtrack to the model stage
func (visualtrack *VisualTrack) StageCopy() *VisualTrack {
	_visualtrack := new(VisualTrack)
	*_visualtrack = *visualtrack
	_visualtrack.Stage()
	return _visualtrack
}

// StageAndCommit appends visualtrack to the model stage and commit to the orm repo
func (visualtrack *VisualTrack) StageAndCommit() *VisualTrack {
	visualtrack.Stage()
	if Stage.AllModelsStructCreateCallback != nil {
		Stage.AllModelsStructCreateCallback.CreateORMVisualTrack(visualtrack)
	}
	return visualtrack
}

// DeleteStageAndCommit appends visualtrack to the model stage and commit to the orm repo
func (visualtrack *VisualTrack) DeleteStageAndCommit() *VisualTrack {
	visualtrack.Unstage()
	DeleteORMVisualTrack(visualtrack)
	return visualtrack
}

// StageCopyAndCommit appends a copy of visualtrack to the model stage and commit to the orm repo
func (visualtrack *VisualTrack) StageCopyAndCommit() *VisualTrack {
	_visualtrack := new(VisualTrack)
	*_visualtrack = *visualtrack
	_visualtrack.Stage()
	if Stage.AllModelsStructCreateCallback != nil {
		Stage.AllModelsStructCreateCallback.CreateORMVisualTrack(visualtrack)
	}
	return _visualtrack
}

// CreateORMVisualTrack enables dynamic staging of a VisualTrack instance
func CreateORMVisualTrack(visualtrack *VisualTrack) {
	visualtrack.Stage()
	if Stage.AllModelsStructCreateCallback != nil {
		Stage.AllModelsStructCreateCallback.CreateORMVisualTrack(visualtrack)
	}
}

// DeleteORMVisualTrack enables dynamic staging of a VisualTrack instance
func DeleteORMVisualTrack(visualtrack *VisualTrack) {
	visualtrack.Unstage()
	if Stage.AllModelsStructDeleteCallback != nil {
		Stage.AllModelsStructDeleteCallback.DeleteORMVisualTrack(visualtrack)
	}
}

// swagger:ignore
type AllModelsStructCreateInterface interface { // insertion point for Callbacks on creation
	CreateORMVisualCenter(VisualCenter *VisualCenter)
	CreateORMVisualCircle(VisualCircle *VisualCircle)
	CreateORMVisualIcon(VisualIcon *VisualIcon)
	CreateORMVisualLayer(VisualLayer *VisualLayer)
	CreateORMVisualLine(VisualLine *VisualLine)
	CreateORMVisualMap(VisualMap *VisualMap)
	CreateORMVisualTrack(VisualTrack *VisualTrack)
}

type AllModelsStructDeleteInterface interface { // insertion point for Callbacks on deletion
	DeleteORMVisualCenter(VisualCenter *VisualCenter)
	DeleteORMVisualCircle(VisualCircle *VisualCircle)
	DeleteORMVisualIcon(VisualIcon *VisualIcon)
	DeleteORMVisualLayer(VisualLayer *VisualLayer)
	DeleteORMVisualLine(VisualLine *VisualLine)
	DeleteORMVisualMap(VisualMap *VisualMap)
	DeleteORMVisualTrack(VisualTrack *VisualTrack)
}

func (stage *StageStruct) Reset() { // insertion point for array reset
	stage.VisualCenters = make(map[*VisualCenter]struct{})
	stage.VisualCenters_mapString = make(map[string]*VisualCenter)

	stage.VisualCircles = make(map[*VisualCircle]struct{})
	stage.VisualCircles_mapString = make(map[string]*VisualCircle)

	stage.VisualIcons = make(map[*VisualIcon]struct{})
	stage.VisualIcons_mapString = make(map[string]*VisualIcon)

	stage.VisualLayers = make(map[*VisualLayer]struct{})
	stage.VisualLayers_mapString = make(map[string]*VisualLayer)

	stage.VisualLines = make(map[*VisualLine]struct{})
	stage.VisualLines_mapString = make(map[string]*VisualLine)

	stage.VisualMaps = make(map[*VisualMap]struct{})
	stage.VisualMaps_mapString = make(map[string]*VisualMap)

	stage.VisualTracks = make(map[*VisualTrack]struct{})
	stage.VisualTracks_mapString = make(map[string]*VisualTrack)

}

func (stage *StageStruct) Nil() { // insertion point for array nil
	stage.VisualCenters = nil
	stage.VisualCenters_mapString = nil

	stage.VisualCircles = nil
	stage.VisualCircles_mapString = nil

	stage.VisualIcons = nil
	stage.VisualIcons_mapString = nil

	stage.VisualLayers = nil
	stage.VisualLayers_mapString = nil

	stage.VisualLines = nil
	stage.VisualLines_mapString = nil

	stage.VisualMaps = nil
	stage.VisualMaps_mapString = nil

	stage.VisualTracks = nil
	stage.VisualTracks_mapString = nil

}
