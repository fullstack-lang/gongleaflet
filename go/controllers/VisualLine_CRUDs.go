// generated by stacks/gong/go/models/controller_file.go
package controllers

import (
	"net/http"
	"time"

	"github.com/fullstack-lang/gongleaflet/go/models"
	"github.com/fullstack-lang/gongleaflet/go/orm"

	"github.com/gin-gonic/gin"
	"github.com/jinzhu/gorm"
)

// declaration in order to justify use of the models import
var __VisualLine__dummysDeclaration__ models.VisualLine
var __VisualLine_time__dummyDeclaration time.Duration

// An VisualLineID parameter model.
//
// This is used for operations that want the ID of an order in the path
// swagger:parameters getVisualLine updateVisualLine deleteVisualLine
type VisualLineID struct {
	// The ID of the order
	//
	// in: path
	// required: true
	ID int64
}

// VisualLineInput is a schema that can validate the userâ€™s
// input to prevent us from getting invalid data
// swagger:parameters postVisualLine updateVisualLine
type VisualLineInput struct {
	// The VisualLine to submit or modify
	// in: body
	VisualLine *orm.VisualLineAPI
}

// GetVisualLines
//
// swagger:route GET /visuallines visuallines getVisualLines
//
// Get all visuallines
//
// Responses:
//    default: genericError
//        200: visuallineDBsResponse
func GetVisualLines(c *gin.Context) {
	db := c.MustGet("db").(*gorm.DB)

	var visuallines []orm.VisualLineDB
	query := db.Find(&visuallines)
	if query.Error != nil {
		var returnError GenericError
		returnError.Body.Code = http.StatusBadRequest
		returnError.Body.Message = query.Error.Error()
		c.JSON(http.StatusBadRequest, returnError.Body)
		return
	}

	// for each visualline, update fields from the database nullable fields
	for idx := range visuallines {
		visualline := &visuallines[idx]
		_ = visualline
		// insertion point for updating fields
		if visualline.StartLat_Data.Valid {
			visualline.StartLat = visualline.StartLat_Data.Float64
		}

		if visualline.StartLng_Data.Valid {
			visualline.StartLng = visualline.StartLng_Data.Float64
		}

		if visualline.EndLat_Data.Valid {
			visualline.EndLat = visualline.EndLat_Data.Float64
		}

		if visualline.EndLng_Data.Valid {
			visualline.EndLng = visualline.EndLng_Data.Float64
		}

		if visualline.Name_Data.Valid {
			visualline.Name = visualline.Name_Data.String
		}

		if visualline.VisualColorEnum_Data.Valid {
			visualline.VisualColorEnum = models.VisualColorEnum(visualline.VisualColorEnum_Data.String)
		}

		if visualline.DashStyleEnum_Data.Valid {
			visualline.DashStyleEnum = models.DashStyleEnum(visualline.DashStyleEnum_Data.String)
		}

		if visualline.IsTransmitting_Data.Valid {
			visualline.IsTransmitting = models.TransmittingEnum(visualline.IsTransmitting_Data.String)
		}

		if visualline.Message_Data.Valid {
			visualline.Message = visualline.Message_Data.String
		}

		if visualline.IsTransmittingBackward_Data.Valid {
			visualline.IsTransmittingBackward = models.TransmittingEnum(visualline.IsTransmittingBackward_Data.String)
		}

		if visualline.MessageBackward_Data.Valid {
			visualline.MessageBackward = visualline.MessageBackward_Data.String
		}

	}

	c.JSON(http.StatusOK, visuallines)
}

// PostVisualLine
//
// swagger:route POST /visuallines visuallines postVisualLine
//
// Creates a visualline
//     Consumes:
//     - application/json
//
//     Produces:
//     - application/json
//
//     Responses:
//       200: visuallineDBResponse
func PostVisualLine(c *gin.Context) {
	db := c.MustGet("db").(*gorm.DB)

	// Validate input
	var input orm.VisualLineAPI

	err := c.ShouldBindJSON(&input)
	if err != nil {
		var returnError GenericError
		returnError.Body.Code = http.StatusBadRequest
		returnError.Body.Message = err.Error()
		c.JSON(http.StatusBadRequest, returnError.Body)
		return
	}

	// Create visualline
	visuallineDB := orm.VisualLineDB{}
	visuallineDB.VisualLineAPI = input
	// insertion point for nullable field set
	visuallineDB.StartLat_Data.Float64 = input.StartLat
	visuallineDB.StartLat_Data.Valid = true

	visuallineDB.StartLng_Data.Float64 = input.StartLng
	visuallineDB.StartLng_Data.Valid = true

	visuallineDB.EndLat_Data.Float64 = input.EndLat
	visuallineDB.EndLat_Data.Valid = true

	visuallineDB.EndLng_Data.Float64 = input.EndLng
	visuallineDB.EndLng_Data.Valid = true

	visuallineDB.Name_Data.String = input.Name
	visuallineDB.Name_Data.Valid = true

	visuallineDB.VisualColorEnum_Data.String = string(input.VisualColorEnum)
	visuallineDB.VisualColorEnum_Data.Valid = true

	visuallineDB.DashStyleEnum_Data.String = string(input.DashStyleEnum)
	visuallineDB.DashStyleEnum_Data.Valid = true

	visuallineDB.IsTransmitting_Data.String = string(input.IsTransmitting)
	visuallineDB.IsTransmitting_Data.Valid = true

	visuallineDB.Message_Data.String = input.Message
	visuallineDB.Message_Data.Valid = true

	visuallineDB.IsTransmittingBackward_Data.String = string(input.IsTransmittingBackward)
	visuallineDB.IsTransmittingBackward_Data.Valid = true

	visuallineDB.MessageBackward_Data.String = input.MessageBackward
	visuallineDB.MessageBackward_Data.Valid = true

	query := db.Create(&visuallineDB)
	if query.Error != nil {
		var returnError GenericError
		returnError.Body.Code = http.StatusBadRequest
		returnError.Body.Message = query.Error.Error()
		c.JSON(http.StatusBadRequest, returnError.Body)
		return
	}

	// a POST is equivalent to a back repo commit increase
	// (this will be improved with implementation of unit of work design pattern)
	orm.BackRepo.IncrementCommitNb()

	c.JSON(http.StatusOK, visuallineDB)
}

// GetVisualLine
//
// swagger:route GET /visuallines/{ID} visuallines getVisualLine
//
// Gets the details for a visualline.
//
// Responses:
//    default: genericError
//        200: visuallineDBResponse
func GetVisualLine(c *gin.Context) {
	db := c.MustGet("db").(*gorm.DB)

	// Get visualline in DB
	var visualline orm.VisualLineDB
	if err := db.First(&visualline, c.Param("id")).Error; err != nil {
		var returnError GenericError
		returnError.Body.Code = http.StatusBadRequest
		returnError.Body.Message = err.Error()
		c.JSON(http.StatusBadRequest, returnError.Body)
		return
	}

	// insertion point for fields value set from nullable fields
	if visualline.StartLat_Data.Valid {
		visualline.StartLat = visualline.StartLat_Data.Float64
	}

	if visualline.StartLng_Data.Valid {
		visualline.StartLng = visualline.StartLng_Data.Float64
	}

	if visualline.EndLat_Data.Valid {
		visualline.EndLat = visualline.EndLat_Data.Float64
	}

	if visualline.EndLng_Data.Valid {
		visualline.EndLng = visualline.EndLng_Data.Float64
	}

	if visualline.Name_Data.Valid {
		visualline.Name = visualline.Name_Data.String
	}

	if visualline.VisualColorEnum_Data.Valid {
		visualline.VisualColorEnum = models.VisualColorEnum(visualline.VisualColorEnum_Data.String)
	}

	if visualline.DashStyleEnum_Data.Valid {
		visualline.DashStyleEnum = models.DashStyleEnum(visualline.DashStyleEnum_Data.String)
	}

	if visualline.IsTransmitting_Data.Valid {
		visualline.IsTransmitting = models.TransmittingEnum(visualline.IsTransmitting_Data.String)
	}

	if visualline.Message_Data.Valid {
		visualline.Message = visualline.Message_Data.String
	}

	if visualline.IsTransmittingBackward_Data.Valid {
		visualline.IsTransmittingBackward = models.TransmittingEnum(visualline.IsTransmittingBackward_Data.String)
	}

	if visualline.MessageBackward_Data.Valid {
		visualline.MessageBackward = visualline.MessageBackward_Data.String
	}

	c.JSON(http.StatusOK, visualline)
}

// UpdateVisualLine
//
// swagger:route PATCH /visuallines/{ID} visuallines updateVisualLine
//
// Update a visualline
//
// Responses:
//    default: genericError
//        200: visuallineDBResponse
func UpdateVisualLine(c *gin.Context) {
	db := c.MustGet("db").(*gorm.DB)

	// Get model if exist
	var visuallineDB orm.VisualLineDB

	// fetch the visualline
	query := db.First(&visuallineDB, c.Param("id"))

	if query.Error != nil {
		var returnError GenericError
		returnError.Body.Code = http.StatusBadRequest
		returnError.Body.Message = query.Error.Error()
		c.JSON(http.StatusBadRequest, returnError.Body)
		return
	}

	// Validate input
	var input orm.VisualLineAPI
	if err := c.ShouldBindJSON(&input); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
		return
	}

	// update
	// insertion point for nullable field set
	input.StartLat_Data.Float64 = input.StartLat
	input.StartLat_Data.Valid = true

	input.StartLng_Data.Float64 = input.StartLng
	input.StartLng_Data.Valid = true

	input.EndLat_Data.Float64 = input.EndLat
	input.EndLat_Data.Valid = true

	input.EndLng_Data.Float64 = input.EndLng
	input.EndLng_Data.Valid = true

	input.Name_Data.String = input.Name
	input.Name_Data.Valid = true

	input.VisualColorEnum_Data.String = string(input.VisualColorEnum)
	input.VisualColorEnum_Data.Valid = true

	input.DashStyleEnum_Data.String = string(input.DashStyleEnum)
	input.DashStyleEnum_Data.Valid = true

	input.IsTransmitting_Data.String = string(input.IsTransmitting)
	input.IsTransmitting_Data.Valid = true

	input.Message_Data.String = input.Message
	input.Message_Data.Valid = true

	input.IsTransmittingBackward_Data.String = string(input.IsTransmittingBackward)
	input.IsTransmittingBackward_Data.Valid = true

	input.MessageBackward_Data.String = input.MessageBackward
	input.MessageBackward_Data.Valid = true

	query = db.Model(&visuallineDB).Updates(input)
	if query.Error != nil {
		var returnError GenericError
		returnError.Body.Code = http.StatusBadRequest
		returnError.Body.Message = query.Error.Error()
		c.JSON(http.StatusBadRequest, returnError.Body)
		return
	}

	// an UPDATE generates a back repo commit increase
	// (this will be improved with implementation of unit of work design pattern)
	orm.BackRepo.IncrementCommitNb()

	// return status OK with the marshalling of the the visuallineDB
	c.JSON(http.StatusOK, visuallineDB)
}

// DeleteVisualLine
//
// swagger:route DELETE /visuallines/{ID} visuallines deleteVisualLine
//
// Delete a visualline
//
// Responses:
//    default: genericError
func DeleteVisualLine(c *gin.Context) {
	db := c.MustGet("db").(*gorm.DB)

	// Get model if exist
	var visuallineDB orm.VisualLineDB
	if err := db.First(&visuallineDB, c.Param("id")).Error; err != nil {
		var returnError GenericError
		returnError.Body.Code = http.StatusBadRequest
		returnError.Body.Message = err.Error()
		c.JSON(http.StatusBadRequest, returnError.Body)
		return
	}

	// with gorm.Model field, default delete is a soft delete. Unscoped() force delete
	db.Unscoped().Delete(&visuallineDB)

	// a DELETE generates a back repo commit increase
	// (this will be improved with implementation of unit of work design pattern)
	orm.BackRepo.IncrementCommitNb()

	c.JSON(http.StatusOK, gin.H{"data": true})
}
