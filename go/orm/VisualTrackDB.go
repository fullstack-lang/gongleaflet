// generated by stacks/gong/go/models/orm_file_per_struct_back_repo.go
package orm

import (
	"database/sql"
	"errors"
	"fmt"
	"log"
	"sort"
	"time"

	"github.com/jinzhu/gorm"

	"github.com/fullstack-lang/gongleaflet/go/models"
)

// dummy variable to have the import declaration wihthout compile failure (even if no code needing this import is generated)
var dummy_VisualTrack sql.NullBool
var __VisualTrack_time__dummyDeclaration time.Duration
var dummy_VisualTrack_sort sort.Float64Slice

// VisualTrackAPI is the input in POST API
//
// for POST, API, one needs the fields of the model as well as the fields
// from associations ("Has One" and "Has Many") that are generated to
// fullfill the ORM requirements for associations
//
// swagger:model visualtrackAPI
type VisualTrackAPI struct {
	models.VisualTrack

	// insertion for fields declaration
	// Declation for basic field visualtrackDB.Lat {{BasicKind}} (to be completed)
	Lat_Data sql.NullFloat64

	// Declation for basic field visualtrackDB.Lng {{BasicKind}} (to be completed)
	Lng_Data sql.NullFloat64

	// Declation for basic field visualtrackDB.Heading {{BasicKind}} (to be completed)
	Heading_Data sql.NullFloat64

	// Declation for basic field visualtrackDB.Level {{BasicKind}} (to be completed)
	Level_Data sql.NullFloat64

	// Declation for basic field visualtrackDB.Speed {{BasicKind}} (to be completed)
	Speed_Data sql.NullFloat64

	// Declation for basic field visualtrackDB.VerticalSpeed {{BasicKind}} (to be completed)
	VerticalSpeed_Data sql.NullFloat64

	// Declation for basic field visualtrackDB.Name {{BasicKind}} (to be completed)
	Name_Data sql.NullString

	// Declation for basic field visualtrackDB.VisualColorEnum {{BasicKind}} (to be completed)
	VisualColorEnum_Data sql.NullString

	// field VisualLayer is a pointer to another Struct (optional or 0..1)
	// This field is generated into another field to enable AS ONE association
	VisualLayerID sql.NullInt64

	// all gong Struct has a Name field, this enables this data to object field
	VisualLayerName string

	// field VisualIcon is a pointer to another Struct (optional or 0..1)
	// This field is generated into another field to enable AS ONE association
	VisualIconID sql.NullInt64

	// all gong Struct has a Name field, this enables this data to object field
	VisualIconName string

	// Declation for basic field visualtrackDB.Display bool (to be completed)
	// provide the sql storage for the boolan
	Display_Data sql.NullBool

	// Declation for basic field visualtrackDB.DisplayTrackHistory bool (to be completed)
	// provide the sql storage for the boolan
	DisplayTrackHistory_Data sql.NullBool

	// Declation for basic field visualtrackDB.DisplayLevelAndSpeed bool (to be completed)
	// provide the sql storage for the boolan
	DisplayLevelAndSpeed_Data sql.NullBool

	// end of insertion
}

// VisualTrackDB describes a visualtrack in the database
//
// It incorporates all fields : from the model, from the generated field for the API and the GORM ID
//
// swagger:model visualtrackDB
type VisualTrackDB struct {
	gorm.Model

	VisualTrackAPI
}

// VisualTrackDBs arrays visualtrackDBs
// swagger:response visualtrackDBsResponse
type VisualTrackDBs []VisualTrackDB

// VisualTrackDBResponse provides response
// swagger:response visualtrackDBResponse
type VisualTrackDBResponse struct {
	VisualTrackDB
}

type BackRepoVisualTrackStruct struct {
	// stores VisualTrackDB according to their gorm ID
	Map_VisualTrackDBID_VisualTrackDB *map[uint]*VisualTrackDB

	// stores VisualTrackDB ID according to VisualTrack address
	Map_VisualTrackPtr_VisualTrackDBID *map[*models.VisualTrack]uint

	// stores VisualTrack according to their gorm ID
	Map_VisualTrackDBID_VisualTrackPtr *map[uint]*models.VisualTrack

	db *gorm.DB
}

// BackRepoVisualTrack.Init set up the BackRepo of the VisualTrack
func (backRepoVisualTrack *BackRepoVisualTrackStruct) Init(db *gorm.DB) (Error error) {

	if backRepoVisualTrack.Map_VisualTrackDBID_VisualTrackPtr != nil {
		err := errors.New("In Init, backRepoVisualTrack.Map_VisualTrackDBID_VisualTrackPtr should be nil")
		return err
	}

	if backRepoVisualTrack.Map_VisualTrackDBID_VisualTrackDB != nil {
		err := errors.New("In Init, backRepoVisualTrack.Map_VisualTrackDBID_VisualTrackDB should be nil")
		return err
	}

	if backRepoVisualTrack.Map_VisualTrackPtr_VisualTrackDBID != nil {
		err := errors.New("In Init, backRepoVisualTrack.Map_VisualTrackPtr_VisualTrackDBID should be nil")
		return err
	}

	tmp := make(map[uint]*models.VisualTrack, 0)
	backRepoVisualTrack.Map_VisualTrackDBID_VisualTrackPtr = &tmp

	tmpDB := make(map[uint]*VisualTrackDB, 0)
	backRepoVisualTrack.Map_VisualTrackDBID_VisualTrackDB = &tmpDB

	tmpID := make(map[*models.VisualTrack]uint, 0)
	backRepoVisualTrack.Map_VisualTrackPtr_VisualTrackDBID = &tmpID

	backRepoVisualTrack.db = db
	return
}

// BackRepoVisualTrack.CommitPhaseOne commits all staged instances of VisualTrack to the BackRepo
// Phase One is the creation of instance in the database if it is not yet done to get the unique ID for each staged instance
func (backRepoVisualTrack *BackRepoVisualTrackStruct) CommitPhaseOne(stage *models.StageStruct) (Error error) {

	for visualtrack := range stage.VisualTracks {
		backRepoVisualTrack.CommitPhaseOneInstance(visualtrack)
	}

	// parse all backRepo instance and checks wether some instance have been unstaged
	// in this case, remove them from the back repo
	for id, visualtrack := range *backRepoVisualTrack.Map_VisualTrackDBID_VisualTrackPtr {
		if _, ok := stage.VisualTracks[visualtrack]; !ok {
			backRepoVisualTrack.CommitDeleteInstance(id)
		}
	}

	return
}

// BackRepoVisualTrack.CommitDeleteInstance commits deletion of VisualTrack to the BackRepo
func (backRepoVisualTrack *BackRepoVisualTrackStruct) CommitDeleteInstance(id uint) (Error error) {

	visualtrack := (*backRepoVisualTrack.Map_VisualTrackDBID_VisualTrackPtr)[id]

	// visualtrack is not staged anymore, remove visualtrackDB
	visualtrackDB := (*backRepoVisualTrack.Map_VisualTrackDBID_VisualTrackDB)[id]
	query := backRepoVisualTrack.db.Unscoped().Delete(&visualtrackDB)
	if query.Error != nil {
		return query.Error
	}

	// update stores
	delete((*backRepoVisualTrack.Map_VisualTrackPtr_VisualTrackDBID), visualtrack)
	delete((*backRepoVisualTrack.Map_VisualTrackDBID_VisualTrackPtr), id)
	delete((*backRepoVisualTrack.Map_VisualTrackDBID_VisualTrackDB), id)

	return
}

// BackRepoVisualTrack.CommitPhaseOneInstance commits visualtrack staged instances of VisualTrack to the BackRepo
// Phase One is the creation of instance in the database if it is not yet done to get the unique ID for each staged instance
func (backRepoVisualTrack *BackRepoVisualTrackStruct) CommitPhaseOneInstance(visualtrack *models.VisualTrack) (Error error) {

	// check if the visualtrack is not commited yet
	if _, ok := (*backRepoVisualTrack.Map_VisualTrackPtr_VisualTrackDBID)[visualtrack]; ok {
		return
	}

	// initiate visualtrack
	var visualtrackDB VisualTrackDB
	visualtrackDB.VisualTrack = *visualtrack

	query := backRepoVisualTrack.db.Create(&visualtrackDB)
	if query.Error != nil {
		return query.Error
	}

	// update stores
	(*backRepoVisualTrack.Map_VisualTrackPtr_VisualTrackDBID)[visualtrack] = visualtrackDB.ID
	(*backRepoVisualTrack.Map_VisualTrackDBID_VisualTrackPtr)[visualtrackDB.ID] = visualtrack
	(*backRepoVisualTrack.Map_VisualTrackDBID_VisualTrackDB)[visualtrackDB.ID] = &visualtrackDB

	return
}

// BackRepoVisualTrack.CommitPhaseTwo commits all staged instances of VisualTrack to the BackRepo
// Phase Two is the update of instance with the field in the database
func (backRepoVisualTrack *BackRepoVisualTrackStruct) CommitPhaseTwo(backRepo *BackRepoStruct) (Error error) {

	for idx, visualtrack := range *backRepoVisualTrack.Map_VisualTrackDBID_VisualTrackPtr {
		backRepoVisualTrack.CommitPhaseTwoInstance(backRepo, idx, visualtrack)
	}

	return
}

// BackRepoVisualTrack.CommitPhaseTwoInstance commits {{structname }} of models.VisualTrack to the BackRepo
// Phase Two is the update of instance with the field in the database
func (backRepoVisualTrack *BackRepoVisualTrackStruct) CommitPhaseTwoInstance(backRepo *BackRepoStruct, idx uint, visualtrack *models.VisualTrack) (Error error) {

	// fetch matching visualtrackDB
	if visualtrackDB, ok := (*backRepoVisualTrack.Map_VisualTrackDBID_VisualTrackDB)[idx]; ok {

		{
			{
				// insertion point for fields commit
				visualtrackDB.Lat_Data.Float64 = visualtrack.Lat
				visualtrackDB.Lat_Data.Valid = true

				visualtrackDB.Lng_Data.Float64 = visualtrack.Lng
				visualtrackDB.Lng_Data.Valid = true

				visualtrackDB.Heading_Data.Float64 = visualtrack.Heading
				visualtrackDB.Heading_Data.Valid = true

				visualtrackDB.Level_Data.Float64 = visualtrack.Level
				visualtrackDB.Level_Data.Valid = true

				visualtrackDB.Speed_Data.Float64 = visualtrack.Speed
				visualtrackDB.Speed_Data.Valid = true

				visualtrackDB.VerticalSpeed_Data.Float64 = visualtrack.VerticalSpeed
				visualtrackDB.VerticalSpeed_Data.Valid = true

				visualtrackDB.Name_Data.String = visualtrack.Name
				visualtrackDB.Name_Data.Valid = true

				visualtrackDB.VisualColorEnum_Data.String = string(visualtrack.VisualColorEnum)
				visualtrackDB.VisualColorEnum_Data.Valid = true

				// commit pointer value visualtrack.VisualLayer translates to updating the visualtrack.VisualLayerID
				visualtrackDB.VisualLayerID.Valid = true // allow for a 0 value (nil association)
				if visualtrack.VisualLayer != nil {
					if VisualLayerId, ok := (*backRepo.BackRepoVisualLayer.Map_VisualLayerPtr_VisualLayerDBID)[visualtrack.VisualLayer]; ok {
						visualtrackDB.VisualLayerID.Int64 = int64(VisualLayerId)
					}
				}

				// commit pointer value visualtrack.VisualIcon translates to updating the visualtrack.VisualIconID
				visualtrackDB.VisualIconID.Valid = true // allow for a 0 value (nil association)
				if visualtrack.VisualIcon != nil {
					if VisualIconId, ok := (*backRepo.BackRepoVisualIcon.Map_VisualIconPtr_VisualIconDBID)[visualtrack.VisualIcon]; ok {
						visualtrackDB.VisualIconID.Int64 = int64(VisualIconId)
					}
				}

				visualtrackDB.Display_Data.Bool = visualtrack.Display
				visualtrackDB.Display_Data.Valid = true

				visualtrackDB.DisplayTrackHistory_Data.Bool = visualtrack.DisplayTrackHistory
				visualtrackDB.DisplayTrackHistory_Data.Valid = true

				visualtrackDB.DisplayLevelAndSpeed_Data.Bool = visualtrack.DisplayLevelAndSpeed
				visualtrackDB.DisplayLevelAndSpeed_Data.Valid = true

			}
		}
		query := backRepoVisualTrack.db.Save(&visualtrackDB)
		if query.Error != nil {
			return query.Error
		}

	} else {
		err := errors.New(
			fmt.Sprintf("Unkown VisualTrack intance %s", visualtrack.Name))
		return err
	}

	return
}

// BackRepoVisualTrack.CheckoutPhaseOne Checkouts all BackRepo instances to the Stage
//
// Phase One is the creation of instance in the stage
//
// NOTE: the is supposed to have been reset before
//
func (backRepoVisualTrack *BackRepoVisualTrackStruct) CheckoutPhaseOne() (Error error) {

	visualtrackDBArray := make([]VisualTrackDB, 0)
	query := backRepoVisualTrack.db.Find(&visualtrackDBArray)
	if query.Error != nil {
		return query.Error
	}

	// copy orm objects to the the map
	for _, visualtrackDB := range visualtrackDBArray {
		backRepoVisualTrack.CheckoutPhaseOneInstance(&visualtrackDB)
	}

	return
}

// CheckoutPhaseOneInstance takes a visualtrackDB that has been found in the DB, updates the backRepo and stages the
// models version of the visualtrackDB
func (backRepoVisualTrack *BackRepoVisualTrackStruct) CheckoutPhaseOneInstance(visualtrackDB *VisualTrackDB) (Error error) {

	// if absent, create entries in the backRepoVisualTrack maps.
	visualtrackWithNewFieldValues := visualtrackDB.VisualTrack
	if _, ok := (*backRepoVisualTrack.Map_VisualTrackDBID_VisualTrackPtr)[visualtrackDB.ID]; !ok {

		(*backRepoVisualTrack.Map_VisualTrackDBID_VisualTrackPtr)[visualtrackDB.ID] = &visualtrackWithNewFieldValues
		(*backRepoVisualTrack.Map_VisualTrackPtr_VisualTrackDBID)[&visualtrackWithNewFieldValues] = visualtrackDB.ID

		// append model store with the new element
		visualtrackWithNewFieldValues.Stage()
	}
	visualtrackDBWithNewFieldValues := *visualtrackDB
	(*backRepoVisualTrack.Map_VisualTrackDBID_VisualTrackDB)[visualtrackDB.ID] = &visualtrackDBWithNewFieldValues

	return
}

// BackRepoVisualTrack.CheckoutPhaseTwo Checkouts all staged instances of VisualTrack to the BackRepo
// Phase Two is the update of instance with the field in the database
func (backRepoVisualTrack *BackRepoVisualTrackStruct) CheckoutPhaseTwo(backRepo *BackRepoStruct) (Error error) {

	// parse all DB instance and update all pointer fields of the translated models instance
	for _, visualtrackDB := range *backRepoVisualTrack.Map_VisualTrackDBID_VisualTrackDB {
		backRepoVisualTrack.CheckoutPhaseTwoInstance(backRepo, visualtrackDB)
	}
	return
}

// BackRepoVisualTrack.CheckoutPhaseTwoInstance Checkouts staged instances of VisualTrack to the BackRepo
// Phase Two is the update of instance with the field in the database
func (backRepoVisualTrack *BackRepoVisualTrackStruct) CheckoutPhaseTwoInstance(backRepo *BackRepoStruct, visualtrackDB *VisualTrackDB) (Error error) {

	visualtrack := (*backRepoVisualTrack.Map_VisualTrackDBID_VisualTrackPtr)[visualtrackDB.ID]
	_ = visualtrack // sometimes, there is no code generated. This lines voids the "unused variable" compilation error
	{
		{
			// insertion point for checkout, i.e. update of fields of stage instance from fields of back repo instances
			//
			visualtrack.Lat = visualtrackDB.Lat_Data.Float64

			visualtrack.Lng = visualtrackDB.Lng_Data.Float64

			visualtrack.Heading = visualtrackDB.Heading_Data.Float64

			visualtrack.Level = visualtrackDB.Level_Data.Float64

			visualtrack.Speed = visualtrackDB.Speed_Data.Float64

			visualtrack.VerticalSpeed = visualtrackDB.VerticalSpeed_Data.Float64

			visualtrack.Name = visualtrackDB.Name_Data.String

			visualtrack.VisualColorEnum = models.VisualColorEnum(visualtrackDB.VisualColorEnum_Data.String)

			// VisualLayer field
			if visualtrackDB.VisualLayerID.Int64 != 0 {
				visualtrack.VisualLayer = (*backRepo.BackRepoVisualLayer.Map_VisualLayerDBID_VisualLayerPtr)[uint(visualtrackDB.VisualLayerID.Int64)]
			}

			// VisualIcon field
			if visualtrackDB.VisualIconID.Int64 != 0 {
				visualtrack.VisualIcon = (*backRepo.BackRepoVisualIcon.Map_VisualIconDBID_VisualIconPtr)[uint(visualtrackDB.VisualIconID.Int64)]
			}

			visualtrack.Display = visualtrackDB.Display_Data.Bool
			visualtrack.DisplayTrackHistory = visualtrackDB.DisplayTrackHistory_Data.Bool
			visualtrack.DisplayLevelAndSpeed = visualtrackDB.DisplayLevelAndSpeed_Data.Bool
		}
	}
	return
}

// CommitVisualTrack allows commit of a single visualtrack (if already staged)
func (backRepo *BackRepoStruct) CommitVisualTrack(visualtrack *models.VisualTrack) {
	backRepo.BackRepoVisualTrack.CommitPhaseOneInstance(visualtrack)
	if id, ok := (*backRepo.BackRepoVisualTrack.Map_VisualTrackPtr_VisualTrackDBID)[visualtrack]; ok {
		backRepo.BackRepoVisualTrack.CommitPhaseTwoInstance(backRepo, id, visualtrack)
	}
}

// CommitVisualTrack allows checkout of a single visualtrack (if already staged and with a BackRepo id)
func (backRepo *BackRepoStruct) CheckoutVisualTrack(visualtrack *models.VisualTrack) {
	// check if the visualtrack is staged
	if _, ok := (*backRepo.BackRepoVisualTrack.Map_VisualTrackPtr_VisualTrackDBID)[visualtrack]; ok {

		if id, ok := (*backRepo.BackRepoVisualTrack.Map_VisualTrackPtr_VisualTrackDBID)[visualtrack]; ok {
			var visualtrackDB VisualTrackDB
			visualtrackDB.ID = id

			if err := backRepo.BackRepoVisualTrack.db.First(&visualtrackDB, id).Error; err != nil {
				log.Panicln("CheckoutVisualTrack : Problem with getting object with id:", id)
			}
			backRepo.BackRepoVisualTrack.CheckoutPhaseOneInstance(&visualtrackDB)
			backRepo.BackRepoVisualTrack.CheckoutPhaseTwoInstance(backRepo, &visualtrackDB)
		}
	}
}
