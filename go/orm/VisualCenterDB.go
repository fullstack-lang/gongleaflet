// generated by stacks/gong/go/models/orm_file_per_struct_back_repo.go
package orm

import (
	"database/sql"
	"encoding/json"
	"errors"
	"fmt"
	"io/ioutil"
	"log"
	"os"
	"path/filepath"
	"sort"
	"time"

	"gorm.io/gorm"

	"github.com/tealeg/xlsx/v3"

	"github.com/fullstack-lang/gongleaflet/go/models"
)

// dummy variable to have the import declaration wihthout compile failure (even if no code needing this import is generated)
var dummy_VisualCenter_sql sql.NullBool
var dummy_VisualCenter_time time.Duration
var dummy_VisualCenter_sort sort.Float64Slice

// VisualCenterAPI is the input in POST API
//
// for POST, API, one needs the fields of the model as well as the fields
// from associations ("Has One" and "Has Many") that are generated to
// fullfill the ORM requirements for associations
//
// swagger:model visualcenterAPI
type VisualCenterAPI struct {
	gorm.Model

	models.VisualCenter

	// encoding of pointers
	VisualCenterPointersEnconding
}

// VisualCenterPointersEnconding encodes pointers to Struct and
// reverse pointers of slice of poitners to Struct
type VisualCenterPointersEnconding struct {
	// insertion for pointer fields encoding declaration
	// field VisualLayer is a pointer to another Struct (optional or 0..1)
	// This field is generated into another field to enable AS ONE association
	VisualLayerID sql.NullInt64

	// field VisualIcon is a pointer to another Struct (optional or 0..1)
	// This field is generated into another field to enable AS ONE association
	VisualIconID sql.NullInt64

}

// VisualCenterDB describes a visualcenter in the database
//
// It incorporates the GORM ID, basic fields from the model (because they can be serialized),
// the encoded version of pointers
//
// swagger:model visualcenterDB
type VisualCenterDB struct {
	gorm.Model

	// insertion for basic fields declaration
	// Declation for basic field visualcenterDB.Lat {{BasicKind}} (to be completed)
	Lat_Data sql.NullFloat64

	// Declation for basic field visualcenterDB.Lng {{BasicKind}} (to be completed)
	Lng_Data sql.NullFloat64

	// Declation for basic field visualcenterDB.Name {{BasicKind}} (to be completed)
	Name_Data sql.NullString

	// Declation for basic field visualcenterDB.VisualColorEnum {{BasicKind}} (to be completed)
	VisualColorEnum_Data sql.NullString

	// encoding of pointers
	VisualCenterPointersEnconding
}

// VisualCenterDBs arrays visualcenterDBs
// swagger:response visualcenterDBsResponse
type VisualCenterDBs []VisualCenterDB

// VisualCenterDBResponse provides response
// swagger:response visualcenterDBResponse
type VisualCenterDBResponse struct {
	VisualCenterDB
}

// VisualCenterWOP is a VisualCenter without pointers (WOP is an acronym for "Without Pointers")
// it holds the same basic fields but pointers are encoded into uint
type VisualCenterWOP struct {
	ID int

	// insertion for WOP basic fields

	Lat float64

	Lng float64

	Name string

	VisualColorEnum models.VisualColorEnum
	// insertion for WOP pointer fields
}

var VisualCenter_Fields = []string{
	// insertion for WOP basic fields
	"ID",
	"Lat",
	"Lng",
	"Name",
	"VisualColorEnum",
}

type BackRepoVisualCenterStruct struct {
	// stores VisualCenterDB according to their gorm ID
	Map_VisualCenterDBID_VisualCenterDB *map[uint]*VisualCenterDB

	// stores VisualCenterDB ID according to VisualCenter address
	Map_VisualCenterPtr_VisualCenterDBID *map[*models.VisualCenter]uint

	// stores VisualCenter according to their gorm ID
	Map_VisualCenterDBID_VisualCenterPtr *map[uint]*models.VisualCenter

	db *gorm.DB
}

func (backRepoVisualCenter *BackRepoVisualCenterStruct) GetDB() *gorm.DB {
	return backRepoVisualCenter.db
}

// GetVisualCenterDBFromVisualCenterPtr is a handy function to access the back repo instance from the stage instance
func (backRepoVisualCenter *BackRepoVisualCenterStruct) GetVisualCenterDBFromVisualCenterPtr(visualcenter *models.VisualCenter) (visualcenterDB *VisualCenterDB) {
	id := (*backRepoVisualCenter.Map_VisualCenterPtr_VisualCenterDBID)[visualcenter]
	visualcenterDB = (*backRepoVisualCenter.Map_VisualCenterDBID_VisualCenterDB)[id]
	return
}

// BackRepoVisualCenter.Init set up the BackRepo of the VisualCenter
func (backRepoVisualCenter *BackRepoVisualCenterStruct) Init(db *gorm.DB) (Error error) {

	if backRepoVisualCenter.Map_VisualCenterDBID_VisualCenterPtr != nil {
		err := errors.New("In Init, backRepoVisualCenter.Map_VisualCenterDBID_VisualCenterPtr should be nil")
		return err
	}

	if backRepoVisualCenter.Map_VisualCenterDBID_VisualCenterDB != nil {
		err := errors.New("In Init, backRepoVisualCenter.Map_VisualCenterDBID_VisualCenterDB should be nil")
		return err
	}

	if backRepoVisualCenter.Map_VisualCenterPtr_VisualCenterDBID != nil {
		err := errors.New("In Init, backRepoVisualCenter.Map_VisualCenterPtr_VisualCenterDBID should be nil")
		return err
	}

	tmp := make(map[uint]*models.VisualCenter, 0)
	backRepoVisualCenter.Map_VisualCenterDBID_VisualCenterPtr = &tmp

	tmpDB := make(map[uint]*VisualCenterDB, 0)
	backRepoVisualCenter.Map_VisualCenterDBID_VisualCenterDB = &tmpDB

	tmpID := make(map[*models.VisualCenter]uint, 0)
	backRepoVisualCenter.Map_VisualCenterPtr_VisualCenterDBID = &tmpID

	backRepoVisualCenter.db = db
	return
}

// BackRepoVisualCenter.CommitPhaseOne commits all staged instances of VisualCenter to the BackRepo
// Phase One is the creation of instance in the database if it is not yet done to get the unique ID for each staged instance
func (backRepoVisualCenter *BackRepoVisualCenterStruct) CommitPhaseOne(stage *models.StageStruct) (Error error) {

	for visualcenter := range stage.VisualCenters {
		backRepoVisualCenter.CommitPhaseOneInstance(visualcenter)
	}

	// parse all backRepo instance and checks wether some instance have been unstaged
	// in this case, remove them from the back repo
	for id, visualcenter := range *backRepoVisualCenter.Map_VisualCenterDBID_VisualCenterPtr {
		if _, ok := stage.VisualCenters[visualcenter]; !ok {
			backRepoVisualCenter.CommitDeleteInstance(id)
		}
	}

	return
}

// BackRepoVisualCenter.CommitDeleteInstance commits deletion of VisualCenter to the BackRepo
func (backRepoVisualCenter *BackRepoVisualCenterStruct) CommitDeleteInstance(id uint) (Error error) {

	visualcenter := (*backRepoVisualCenter.Map_VisualCenterDBID_VisualCenterPtr)[id]

	// visualcenter is not staged anymore, remove visualcenterDB
	visualcenterDB := (*backRepoVisualCenter.Map_VisualCenterDBID_VisualCenterDB)[id]
	query := backRepoVisualCenter.db.Unscoped().Delete(&visualcenterDB)
	if query.Error != nil {
		return query.Error
	}

	// update stores
	delete((*backRepoVisualCenter.Map_VisualCenterPtr_VisualCenterDBID), visualcenter)
	delete((*backRepoVisualCenter.Map_VisualCenterDBID_VisualCenterPtr), id)
	delete((*backRepoVisualCenter.Map_VisualCenterDBID_VisualCenterDB), id)

	return
}

// BackRepoVisualCenter.CommitPhaseOneInstance commits visualcenter staged instances of VisualCenter to the BackRepo
// Phase One is the creation of instance in the database if it is not yet done to get the unique ID for each staged instance
func (backRepoVisualCenter *BackRepoVisualCenterStruct) CommitPhaseOneInstance(visualcenter *models.VisualCenter) (Error error) {

	// check if the visualcenter is not commited yet
	if _, ok := (*backRepoVisualCenter.Map_VisualCenterPtr_VisualCenterDBID)[visualcenter]; ok {
		return
	}

	// initiate visualcenter
	var visualcenterDB VisualCenterDB
	visualcenterDB.CopyBasicFieldsFromVisualCenter(visualcenter)

	query := backRepoVisualCenter.db.Create(&visualcenterDB)
	if query.Error != nil {
		return query.Error
	}

	// update stores
	(*backRepoVisualCenter.Map_VisualCenterPtr_VisualCenterDBID)[visualcenter] = visualcenterDB.ID
	(*backRepoVisualCenter.Map_VisualCenterDBID_VisualCenterPtr)[visualcenterDB.ID] = visualcenter
	(*backRepoVisualCenter.Map_VisualCenterDBID_VisualCenterDB)[visualcenterDB.ID] = &visualcenterDB

	return
}

// BackRepoVisualCenter.CommitPhaseTwo commits all staged instances of VisualCenter to the BackRepo
// Phase Two is the update of instance with the field in the database
func (backRepoVisualCenter *BackRepoVisualCenterStruct) CommitPhaseTwo(backRepo *BackRepoStruct) (Error error) {

	for idx, visualcenter := range *backRepoVisualCenter.Map_VisualCenterDBID_VisualCenterPtr {
		backRepoVisualCenter.CommitPhaseTwoInstance(backRepo, idx, visualcenter)
	}

	return
}

// BackRepoVisualCenter.CommitPhaseTwoInstance commits {{structname }} of models.VisualCenter to the BackRepo
// Phase Two is the update of instance with the field in the database
func (backRepoVisualCenter *BackRepoVisualCenterStruct) CommitPhaseTwoInstance(backRepo *BackRepoStruct, idx uint, visualcenter *models.VisualCenter) (Error error) {

	// fetch matching visualcenterDB
	if visualcenterDB, ok := (*backRepoVisualCenter.Map_VisualCenterDBID_VisualCenterDB)[idx]; ok {

		visualcenterDB.CopyBasicFieldsFromVisualCenter(visualcenter)

		// insertion point for translating pointers encodings into actual pointers
		// commit pointer value visualcenter.VisualLayer translates to updating the visualcenter.VisualLayerID
		visualcenterDB.VisualLayerID.Valid = true // allow for a 0 value (nil association)
		if visualcenter.VisualLayer != nil {
			if VisualLayerId, ok := (*backRepo.BackRepoVisualLayer.Map_VisualLayerPtr_VisualLayerDBID)[visualcenter.VisualLayer]; ok {
				visualcenterDB.VisualLayerID.Int64 = int64(VisualLayerId)
				visualcenterDB.VisualLayerID.Valid = true
			}
		}

		// commit pointer value visualcenter.VisualIcon translates to updating the visualcenter.VisualIconID
		visualcenterDB.VisualIconID.Valid = true // allow for a 0 value (nil association)
		if visualcenter.VisualIcon != nil {
			if VisualIconId, ok := (*backRepo.BackRepoVisualIcon.Map_VisualIconPtr_VisualIconDBID)[visualcenter.VisualIcon]; ok {
				visualcenterDB.VisualIconID.Int64 = int64(VisualIconId)
				visualcenterDB.VisualIconID.Valid = true
			}
		}

		query := backRepoVisualCenter.db.Save(&visualcenterDB)
		if query.Error != nil {
			return query.Error
		}

	} else {
		err := errors.New(
			fmt.Sprintf("Unkown VisualCenter intance %s", visualcenter.Name))
		return err
	}

	return
}

// BackRepoVisualCenter.CheckoutPhaseOne Checkouts all BackRepo instances to the Stage
//
// Phase One will result in having instances on the stage aligned with the back repo
// pointers are not initialized yet (this is for pahse two)
//
func (backRepoVisualCenter *BackRepoVisualCenterStruct) CheckoutPhaseOne() (Error error) {

	visualcenterDBArray := make([]VisualCenterDB, 0)
	query := backRepoVisualCenter.db.Find(&visualcenterDBArray)
	if query.Error != nil {
		return query.Error
	}

	// list of instances to be removed
	// start from the initial map on the stage and remove instances that have been checked out
	visualcenterInstancesToBeRemovedFromTheStage := make(map[*models.VisualCenter]struct{})
	for key, value := range models.Stage.VisualCenters {
		visualcenterInstancesToBeRemovedFromTheStage[key] = value
	}

	// copy orm objects to the the map
	for _, visualcenterDB := range visualcenterDBArray {
		backRepoVisualCenter.CheckoutPhaseOneInstance(&visualcenterDB)

		// do not remove this instance from the stage, therefore
		// remove instance from the list of instances to be be removed from the stage
		visualcenter, ok := (*backRepoVisualCenter.Map_VisualCenterDBID_VisualCenterPtr)[visualcenterDB.ID]
		if ok {
			delete(visualcenterInstancesToBeRemovedFromTheStage, visualcenter)
		}
	}

	// remove from stage and back repo's 3 maps all visualcenters that are not in the checkout
	for visualcenter := range visualcenterInstancesToBeRemovedFromTheStage {
		visualcenter.Unstage()

		// remove instance from the back repo 3 maps
		visualcenterID := (*backRepoVisualCenter.Map_VisualCenterPtr_VisualCenterDBID)[visualcenter]
		delete((*backRepoVisualCenter.Map_VisualCenterPtr_VisualCenterDBID), visualcenter)
		delete((*backRepoVisualCenter.Map_VisualCenterDBID_VisualCenterDB), visualcenterID)
		delete((*backRepoVisualCenter.Map_VisualCenterDBID_VisualCenterPtr), visualcenterID)
	}

	return
}

// CheckoutPhaseOneInstance takes a visualcenterDB that has been found in the DB, updates the backRepo and stages the
// models version of the visualcenterDB
func (backRepoVisualCenter *BackRepoVisualCenterStruct) CheckoutPhaseOneInstance(visualcenterDB *VisualCenterDB) (Error error) {

	visualcenter, ok := (*backRepoVisualCenter.Map_VisualCenterDBID_VisualCenterPtr)[visualcenterDB.ID]
	if !ok {
		visualcenter = new(models.VisualCenter)

		(*backRepoVisualCenter.Map_VisualCenterDBID_VisualCenterPtr)[visualcenterDB.ID] = visualcenter
		(*backRepoVisualCenter.Map_VisualCenterPtr_VisualCenterDBID)[visualcenter] = visualcenterDB.ID

		// append model store with the new element
		visualcenter.Name = visualcenterDB.Name_Data.String
		visualcenter.Stage()
	}
	visualcenterDB.CopyBasicFieldsToVisualCenter(visualcenter)

	// preserve pointer to visualcenterDB. Otherwise, pointer will is recycled and the map of pointers
	// Map_VisualCenterDBID_VisualCenterDB)[visualcenterDB hold variable pointers
	visualcenterDB_Data := *visualcenterDB
	preservedPtrToVisualCenter := &visualcenterDB_Data
	(*backRepoVisualCenter.Map_VisualCenterDBID_VisualCenterDB)[visualcenterDB.ID] = preservedPtrToVisualCenter

	return
}

// BackRepoVisualCenter.CheckoutPhaseTwo Checkouts all staged instances of VisualCenter to the BackRepo
// Phase Two is the update of instance with the field in the database
func (backRepoVisualCenter *BackRepoVisualCenterStruct) CheckoutPhaseTwo(backRepo *BackRepoStruct) (Error error) {

	// parse all DB instance and update all pointer fields of the translated models instance
	for _, visualcenterDB := range *backRepoVisualCenter.Map_VisualCenterDBID_VisualCenterDB {
		backRepoVisualCenter.CheckoutPhaseTwoInstance(backRepo, visualcenterDB)
	}
	return
}

// BackRepoVisualCenter.CheckoutPhaseTwoInstance Checkouts staged instances of VisualCenter to the BackRepo
// Phase Two is the update of instance with the field in the database
func (backRepoVisualCenter *BackRepoVisualCenterStruct) CheckoutPhaseTwoInstance(backRepo *BackRepoStruct, visualcenterDB *VisualCenterDB) (Error error) {

	visualcenter := (*backRepoVisualCenter.Map_VisualCenterDBID_VisualCenterPtr)[visualcenterDB.ID]
	_ = visualcenter // sometimes, there is no code generated. This lines voids the "unused variable" compilation error

	// insertion point for checkout of pointer encoding
	// VisualLayer field
	if visualcenterDB.VisualLayerID.Int64 != 0 {
		visualcenter.VisualLayer = (*backRepo.BackRepoVisualLayer.Map_VisualLayerDBID_VisualLayerPtr)[uint(visualcenterDB.VisualLayerID.Int64)]
	}
	// VisualIcon field
	if visualcenterDB.VisualIconID.Int64 != 0 {
		visualcenter.VisualIcon = (*backRepo.BackRepoVisualIcon.Map_VisualIconDBID_VisualIconPtr)[uint(visualcenterDB.VisualIconID.Int64)]
	}
	return
}

// CommitVisualCenter allows commit of a single visualcenter (if already staged)
func (backRepo *BackRepoStruct) CommitVisualCenter(visualcenter *models.VisualCenter) {
	backRepo.BackRepoVisualCenter.CommitPhaseOneInstance(visualcenter)
	if id, ok := (*backRepo.BackRepoVisualCenter.Map_VisualCenterPtr_VisualCenterDBID)[visualcenter]; ok {
		backRepo.BackRepoVisualCenter.CommitPhaseTwoInstance(backRepo, id, visualcenter)
	}
}

// CommitVisualCenter allows checkout of a single visualcenter (if already staged and with a BackRepo id)
func (backRepo *BackRepoStruct) CheckoutVisualCenter(visualcenter *models.VisualCenter) {
	// check if the visualcenter is staged
	if _, ok := (*backRepo.BackRepoVisualCenter.Map_VisualCenterPtr_VisualCenterDBID)[visualcenter]; ok {

		if id, ok := (*backRepo.BackRepoVisualCenter.Map_VisualCenterPtr_VisualCenterDBID)[visualcenter]; ok {
			var visualcenterDB VisualCenterDB
			visualcenterDB.ID = id

			if err := backRepo.BackRepoVisualCenter.db.First(&visualcenterDB, id).Error; err != nil {
				log.Panicln("CheckoutVisualCenter : Problem with getting object with id:", id)
			}
			backRepo.BackRepoVisualCenter.CheckoutPhaseOneInstance(&visualcenterDB)
			backRepo.BackRepoVisualCenter.CheckoutPhaseTwoInstance(backRepo, &visualcenterDB)
		}
	}
}

// CopyBasicFieldsFromVisualCenter
func (visualcenterDB *VisualCenterDB) CopyBasicFieldsFromVisualCenter(visualcenter *models.VisualCenter) {
	// insertion point for fields commit
	visualcenterDB.Lat_Data.Float64 = visualcenter.Lat
	visualcenterDB.Lat_Data.Valid = true

	visualcenterDB.Lng_Data.Float64 = visualcenter.Lng
	visualcenterDB.Lng_Data.Valid = true

	visualcenterDB.Name_Data.String = visualcenter.Name
	visualcenterDB.Name_Data.Valid = true

	visualcenterDB.VisualColorEnum_Data.String = string(visualcenter.VisualColorEnum)
	visualcenterDB.VisualColorEnum_Data.Valid = true

}

// CopyBasicFieldsFromVisualCenterWOP
func (visualcenterDB *VisualCenterDB) CopyBasicFieldsFromVisualCenterWOP(visualcenter *VisualCenterWOP) {
	// insertion point for fields commit
	visualcenterDB.Lat_Data.Float64 = visualcenter.Lat
	visualcenterDB.Lat_Data.Valid = true

	visualcenterDB.Lng_Data.Float64 = visualcenter.Lng
	visualcenterDB.Lng_Data.Valid = true

	visualcenterDB.Name_Data.String = visualcenter.Name
	visualcenterDB.Name_Data.Valid = true

	visualcenterDB.VisualColorEnum_Data.String = string(visualcenter.VisualColorEnum)
	visualcenterDB.VisualColorEnum_Data.Valid = true

}

// CopyBasicFieldsToVisualCenter
func (visualcenterDB *VisualCenterDB) CopyBasicFieldsToVisualCenter(visualcenter *models.VisualCenter) {
	// insertion point for checkout of basic fields (back repo to stage)
	visualcenter.Lat = visualcenterDB.Lat_Data.Float64
	visualcenter.Lng = visualcenterDB.Lng_Data.Float64
	visualcenter.Name = visualcenterDB.Name_Data.String
	visualcenter.VisualColorEnum = models.VisualColorEnum(visualcenterDB.VisualColorEnum_Data.String)
}

// CopyBasicFieldsToVisualCenterWOP
func (visualcenterDB *VisualCenterDB) CopyBasicFieldsToVisualCenterWOP(visualcenter *VisualCenterWOP) {
	visualcenter.ID = int(visualcenterDB.ID)
	// insertion point for checkout of basic fields (back repo to stage)
	visualcenter.Lat = visualcenterDB.Lat_Data.Float64
	visualcenter.Lng = visualcenterDB.Lng_Data.Float64
	visualcenter.Name = visualcenterDB.Name_Data.String
	visualcenter.VisualColorEnum = models.VisualColorEnum(visualcenterDB.VisualColorEnum_Data.String)
}

// Backup generates a json file from a slice of all VisualCenterDB instances in the backrepo
func (backRepoVisualCenter *BackRepoVisualCenterStruct) Backup(dirPath string) {

	filename := filepath.Join(dirPath, "VisualCenterDB.json")

	// organize the map into an array with increasing IDs, in order to have repoductible
	// backup file
	forBackup := make([]*VisualCenterDB, 0)
	for _, visualcenterDB := range *backRepoVisualCenter.Map_VisualCenterDBID_VisualCenterDB {
		forBackup = append(forBackup, visualcenterDB)
	}

	sort.Slice(forBackup[:], func(i, j int) bool {
		return forBackup[i].ID < forBackup[j].ID
	})

	file, err := json.MarshalIndent(forBackup, "", " ")

	if err != nil {
		log.Panic("Cannot json VisualCenter ", filename, " ", err.Error())
	}

	err = ioutil.WriteFile(filename, file, 0644)
	if err != nil {
		log.Panic("Cannot write the json VisualCenter file", err.Error())
	}
}

// Backup generates a json file from a slice of all VisualCenterDB instances in the backrepo
func (backRepoVisualCenter *BackRepoVisualCenterStruct) BackupXL(file *xlsx.File) {

	// organize the map into an array with increasing IDs, in order to have repoductible
	// backup file
	forBackup := make([]*VisualCenterDB, 0)
	for _, visualcenterDB := range *backRepoVisualCenter.Map_VisualCenterDBID_VisualCenterDB {
		forBackup = append(forBackup, visualcenterDB)
	}

	sort.Slice(forBackup[:], func(i, j int) bool {
		return forBackup[i].ID < forBackup[j].ID
	})

	sh, err := file.AddSheet("VisualCenter")
	if err != nil {
		log.Panic("Cannot add XL file", err.Error())
	}
	_ = sh

	row := sh.AddRow()
	row.WriteSlice(&VisualCenter_Fields, -1)
	for _, visualcenterDB := range forBackup {

		var visualcenterWOP VisualCenterWOP
		visualcenterDB.CopyBasicFieldsToVisualCenterWOP(&visualcenterWOP)

		row := sh.AddRow()
		row.WriteStruct(&visualcenterWOP, -1)
	}
}

// RestorePhaseOne read the file "VisualCenterDB.json" in dirPath that stores an array
// of VisualCenterDB and stores it in the database
// the map BackRepoVisualCenterid_atBckpTime_newID is updated accordingly
func (backRepoVisualCenter *BackRepoVisualCenterStruct) RestorePhaseOne(dirPath string) {

	// resets the map
	BackRepoVisualCenterid_atBckpTime_newID = make(map[uint]uint)

	filename := filepath.Join(dirPath, "VisualCenterDB.json")
	jsonFile, err := os.Open(filename)
	// if we os.Open returns an error then handle it
	if err != nil {
		log.Panic("Cannot restore/open the json VisualCenter file", filename, " ", err.Error())
	}

	// read our opened jsonFile as a byte array.
	byteValue, _ := ioutil.ReadAll(jsonFile)

	var forRestore []*VisualCenterDB

	err = json.Unmarshal(byteValue, &forRestore)

	// fill up Map_VisualCenterDBID_VisualCenterDB
	for _, visualcenterDB := range forRestore {

		visualcenterDB_ID_atBackupTime := visualcenterDB.ID
		visualcenterDB.ID = 0
		query := backRepoVisualCenter.db.Create(visualcenterDB)
		if query.Error != nil {
			log.Panic(query.Error)
		}
		(*backRepoVisualCenter.Map_VisualCenterDBID_VisualCenterDB)[visualcenterDB.ID] = visualcenterDB
		BackRepoVisualCenterid_atBckpTime_newID[visualcenterDB_ID_atBackupTime] = visualcenterDB.ID
	}

	if err != nil {
		log.Panic("Cannot restore/unmarshall json VisualCenter file", err.Error())
	}
}

// RestorePhaseTwo uses all map BackRepo<VisualCenter>id_atBckpTime_newID
// to compute new index
func (backRepoVisualCenter *BackRepoVisualCenterStruct) RestorePhaseTwo() {

	for _, visualcenterDB := range *backRepoVisualCenter.Map_VisualCenterDBID_VisualCenterDB {

		// next line of code is to avert unused variable compilation error
		_ = visualcenterDB

		// insertion point for reindexing pointers encoding
		// reindexing VisualLayer field
		if visualcenterDB.VisualLayerID.Int64 != 0 {
			visualcenterDB.VisualLayerID.Int64 = int64(BackRepoVisualLayerid_atBckpTime_newID[uint(visualcenterDB.VisualLayerID.Int64)])
			visualcenterDB.VisualLayerID.Valid = true
		}

		// reindexing VisualIcon field
		if visualcenterDB.VisualIconID.Int64 != 0 {
			visualcenterDB.VisualIconID.Int64 = int64(BackRepoVisualIconid_atBckpTime_newID[uint(visualcenterDB.VisualIconID.Int64)])
			visualcenterDB.VisualIconID.Valid = true
		}

		// update databse with new index encoding
		query := backRepoVisualCenter.db.Model(visualcenterDB).Updates(*visualcenterDB)
		if query.Error != nil {
			log.Panic(query.Error)
		}
	}

}

// this field is used during the restauration process.
// it stores the ID at the backup time and is used for renumbering
var BackRepoVisualCenterid_atBckpTime_newID map[uint]uint
