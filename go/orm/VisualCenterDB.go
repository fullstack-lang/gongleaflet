// generated by stacks/gong/go/models/orm_file_per_struct_back_repo.go
package orm

import (
	"database/sql"
	"errors"
	"fmt"
	"log"
	"sort"
	"time"

	"github.com/jinzhu/gorm"

	"github.com/fullstack-lang/gongleaflet/go/models"
)

// dummy variable to have the import declaration wihthout compile failure (even if no code needing this import is generated)
var dummy_VisualCenter sql.NullBool
var __VisualCenter_time__dummyDeclaration time.Duration
var dummy_VisualCenter_sort sort.Float64Slice

// VisualCenterAPI is the input in POST API
//
// for POST, API, one needs the fields of the model as well as the fields
// from associations ("Has One" and "Has Many") that are generated to
// fullfill the ORM requirements for associations
//
// swagger:model visualcenterAPI
type VisualCenterAPI struct {
	models.VisualCenter

	// insertion for fields declaration
	// Declation for basic field visualcenterDB.Lat {{BasicKind}} (to be completed)
	Lat_Data sql.NullFloat64

	// Declation for basic field visualcenterDB.Lng {{BasicKind}} (to be completed)
	Lng_Data sql.NullFloat64

	// Declation for basic field visualcenterDB.Name {{BasicKind}} (to be completed)
	Name_Data sql.NullString

	// Declation for basic field visualcenterDB.VisualColorEnum {{BasicKind}} (to be completed)
	VisualColorEnum_Data sql.NullString

	// field VisualLayer is a pointer to another Struct (optional or 0..1)
	// This field is generated into another field to enable AS ONE association
	VisualLayerID sql.NullInt64

	// all gong Struct has a Name field, this enables this data to object field
	VisualLayerName string

	// field VisualIcon is a pointer to another Struct (optional or 0..1)
	// This field is generated into another field to enable AS ONE association
	VisualIconID sql.NullInt64

	// all gong Struct has a Name field, this enables this data to object field
	VisualIconName string

	// end of insertion
}

// VisualCenterDB describes a visualcenter in the database
//
// It incorporates all fields : from the model, from the generated field for the API and the GORM ID
//
// swagger:model visualcenterDB
type VisualCenterDB struct {
	gorm.Model

	VisualCenterAPI
}

// VisualCenterDBs arrays visualcenterDBs
// swagger:response visualcenterDBsResponse
type VisualCenterDBs []VisualCenterDB

// VisualCenterDBResponse provides response
// swagger:response visualcenterDBResponse
type VisualCenterDBResponse struct {
	VisualCenterDB
}

type BackRepoVisualCenterStruct struct {
	// stores VisualCenterDB according to their gorm ID
	Map_VisualCenterDBID_VisualCenterDB *map[uint]*VisualCenterDB

	// stores VisualCenterDB ID according to VisualCenter address
	Map_VisualCenterPtr_VisualCenterDBID *map[*models.VisualCenter]uint

	// stores VisualCenter according to their gorm ID
	Map_VisualCenterDBID_VisualCenterPtr *map[uint]*models.VisualCenter

	db *gorm.DB
}

// BackRepoVisualCenter.Init set up the BackRepo of the VisualCenter
func (backRepoVisualCenter *BackRepoVisualCenterStruct) Init(db *gorm.DB) (Error error) {

	if backRepoVisualCenter.Map_VisualCenterDBID_VisualCenterPtr != nil {
		err := errors.New("In Init, backRepoVisualCenter.Map_VisualCenterDBID_VisualCenterPtr should be nil")
		return err
	}

	if backRepoVisualCenter.Map_VisualCenterDBID_VisualCenterDB != nil {
		err := errors.New("In Init, backRepoVisualCenter.Map_VisualCenterDBID_VisualCenterDB should be nil")
		return err
	}

	if backRepoVisualCenter.Map_VisualCenterPtr_VisualCenterDBID != nil {
		err := errors.New("In Init, backRepoVisualCenter.Map_VisualCenterPtr_VisualCenterDBID should be nil")
		return err
	}

	tmp := make(map[uint]*models.VisualCenter, 0)
	backRepoVisualCenter.Map_VisualCenterDBID_VisualCenterPtr = &tmp

	tmpDB := make(map[uint]*VisualCenterDB, 0)
	backRepoVisualCenter.Map_VisualCenterDBID_VisualCenterDB = &tmpDB

	tmpID := make(map[*models.VisualCenter]uint, 0)
	backRepoVisualCenter.Map_VisualCenterPtr_VisualCenterDBID = &tmpID

	backRepoVisualCenter.db = db
	return
}

// BackRepoVisualCenter.CommitPhaseOne commits all staged instances of VisualCenter to the BackRepo
// Phase One is the creation of instance in the database if it is not yet done to get the unique ID for each staged instance
func (backRepoVisualCenter *BackRepoVisualCenterStruct) CommitPhaseOne(stage *models.StageStruct) (Error error) {

	for visualcenter := range stage.VisualCenters {
		backRepoVisualCenter.CommitPhaseOneInstance(visualcenter)
	}

	// parse all backRepo instance and checks wether some instance have been unstaged
	// in this case, remove them from the back repo
	for id, visualcenter := range *backRepoVisualCenter.Map_VisualCenterDBID_VisualCenterPtr {
		if _, ok := stage.VisualCenters[visualcenter]; !ok {
			backRepoVisualCenter.CommitDeleteInstance(id)
		}
	}

	return
}

// BackRepoVisualCenter.CommitDeleteInstance commits deletion of VisualCenter to the BackRepo
func (backRepoVisualCenter *BackRepoVisualCenterStruct) CommitDeleteInstance(id uint) (Error error) {

	visualcenter := (*backRepoVisualCenter.Map_VisualCenterDBID_VisualCenterPtr)[id]

	// visualcenter is not staged anymore, remove visualcenterDB
	visualcenterDB := (*backRepoVisualCenter.Map_VisualCenterDBID_VisualCenterDB)[id]
	query := backRepoVisualCenter.db.Unscoped().Delete(&visualcenterDB)
	if query.Error != nil {
		return query.Error
	}

	// update stores
	delete((*backRepoVisualCenter.Map_VisualCenterPtr_VisualCenterDBID), visualcenter)
	delete((*backRepoVisualCenter.Map_VisualCenterDBID_VisualCenterPtr), id)
	delete((*backRepoVisualCenter.Map_VisualCenterDBID_VisualCenterDB), id)

	return
}

// BackRepoVisualCenter.CommitPhaseOneInstance commits visualcenter staged instances of VisualCenter to the BackRepo
// Phase One is the creation of instance in the database if it is not yet done to get the unique ID for each staged instance
func (backRepoVisualCenter *BackRepoVisualCenterStruct) CommitPhaseOneInstance(visualcenter *models.VisualCenter) (Error error) {

	// check if the visualcenter is not commited yet
	if _, ok := (*backRepoVisualCenter.Map_VisualCenterPtr_VisualCenterDBID)[visualcenter]; ok {
		return
	}

	// initiate visualcenter
	var visualcenterDB VisualCenterDB
	visualcenterDB.VisualCenter = *visualcenter

	query := backRepoVisualCenter.db.Create(&visualcenterDB)
	if query.Error != nil {
		return query.Error
	}

	// update stores
	(*backRepoVisualCenter.Map_VisualCenterPtr_VisualCenterDBID)[visualcenter] = visualcenterDB.ID
	(*backRepoVisualCenter.Map_VisualCenterDBID_VisualCenterPtr)[visualcenterDB.ID] = visualcenter
	(*backRepoVisualCenter.Map_VisualCenterDBID_VisualCenterDB)[visualcenterDB.ID] = &visualcenterDB

	return
}

// BackRepoVisualCenter.CommitPhaseTwo commits all staged instances of VisualCenter to the BackRepo
// Phase Two is the update of instance with the field in the database
func (backRepoVisualCenter *BackRepoVisualCenterStruct) CommitPhaseTwo(backRepo *BackRepoStruct) (Error error) {

	for idx, visualcenter := range *backRepoVisualCenter.Map_VisualCenterDBID_VisualCenterPtr {
		backRepoVisualCenter.CommitPhaseTwoInstance(backRepo, idx, visualcenter)
	}

	return
}

// BackRepoVisualCenter.CommitPhaseTwoInstance commits {{structname }} of models.VisualCenter to the BackRepo
// Phase Two is the update of instance with the field in the database
func (backRepoVisualCenter *BackRepoVisualCenterStruct) CommitPhaseTwoInstance(backRepo *BackRepoStruct, idx uint, visualcenter *models.VisualCenter) (Error error) {

	// fetch matching visualcenterDB
	if visualcenterDB, ok := (*backRepoVisualCenter.Map_VisualCenterDBID_VisualCenterDB)[idx]; ok {

		{
			{
				// insertion point for fields commit
				visualcenterDB.Lat_Data.Float64 = visualcenter.Lat
				visualcenterDB.Lat_Data.Valid = true

				visualcenterDB.Lng_Data.Float64 = visualcenter.Lng
				visualcenterDB.Lng_Data.Valid = true

				visualcenterDB.Name_Data.String = visualcenter.Name
				visualcenterDB.Name_Data.Valid = true

				visualcenterDB.VisualColorEnum_Data.String = string(visualcenter.VisualColorEnum)
				visualcenterDB.VisualColorEnum_Data.Valid = true

				// commit pointer value visualcenter.VisualLayer translates to updating the visualcenter.VisualLayerID
				visualcenterDB.VisualLayerID.Valid = true // allow for a 0 value (nil association)
				if visualcenter.VisualLayer != nil {
					if VisualLayerId, ok := (*backRepo.BackRepoVisualLayer.Map_VisualLayerPtr_VisualLayerDBID)[visualcenter.VisualLayer]; ok {
						visualcenterDB.VisualLayerID.Int64 = int64(VisualLayerId)
					}
				}

				// commit pointer value visualcenter.VisualIcon translates to updating the visualcenter.VisualIconID
				visualcenterDB.VisualIconID.Valid = true // allow for a 0 value (nil association)
				if visualcenter.VisualIcon != nil {
					if VisualIconId, ok := (*backRepo.BackRepoVisualIcon.Map_VisualIconPtr_VisualIconDBID)[visualcenter.VisualIcon]; ok {
						visualcenterDB.VisualIconID.Int64 = int64(VisualIconId)
					}
				}

			}
		}
		query := backRepoVisualCenter.db.Save(&visualcenterDB)
		if query.Error != nil {
			return query.Error
		}

	} else {
		err := errors.New(
			fmt.Sprintf("Unkown VisualCenter intance %s", visualcenter.Name))
		return err
	}

	return
}

// BackRepoVisualCenter.CheckoutPhaseOne Checkouts all BackRepo instances to the Stage
//
// Phase One is the creation of instance in the stage
//
// NOTE: the is supposed to have been reset before
//
func (backRepoVisualCenter *BackRepoVisualCenterStruct) CheckoutPhaseOne() (Error error) {

	visualcenterDBArray := make([]VisualCenterDB, 0)
	query := backRepoVisualCenter.db.Find(&visualcenterDBArray)
	if query.Error != nil {
		return query.Error
	}

	// copy orm objects to the the map
	for _, visualcenterDB := range visualcenterDBArray {
		backRepoVisualCenter.CheckoutPhaseOneInstance(&visualcenterDB)
	}

	return
}

// CheckoutPhaseOneInstance takes a visualcenterDB that has been found in the DB, updates the backRepo and stages the
// models version of the visualcenterDB
func (backRepoVisualCenter *BackRepoVisualCenterStruct) CheckoutPhaseOneInstance(visualcenterDB *VisualCenterDB) (Error error) {

	// if absent, create entries in the backRepoVisualCenter maps.
	visualcenterWithNewFieldValues := visualcenterDB.VisualCenter
	if _, ok := (*backRepoVisualCenter.Map_VisualCenterDBID_VisualCenterPtr)[visualcenterDB.ID]; !ok {

		(*backRepoVisualCenter.Map_VisualCenterDBID_VisualCenterPtr)[visualcenterDB.ID] = &visualcenterWithNewFieldValues
		(*backRepoVisualCenter.Map_VisualCenterPtr_VisualCenterDBID)[&visualcenterWithNewFieldValues] = visualcenterDB.ID

		// append model store with the new element
		visualcenterWithNewFieldValues.Stage()
	}
	visualcenterDBWithNewFieldValues := *visualcenterDB
	(*backRepoVisualCenter.Map_VisualCenterDBID_VisualCenterDB)[visualcenterDB.ID] = &visualcenterDBWithNewFieldValues

	return
}

// BackRepoVisualCenter.CheckoutPhaseTwo Checkouts all staged instances of VisualCenter to the BackRepo
// Phase Two is the update of instance with the field in the database
func (backRepoVisualCenter *BackRepoVisualCenterStruct) CheckoutPhaseTwo(backRepo *BackRepoStruct) (Error error) {

	// parse all DB instance and update all pointer fields of the translated models instance
	for _, visualcenterDB := range *backRepoVisualCenter.Map_VisualCenterDBID_VisualCenterDB {
		backRepoVisualCenter.CheckoutPhaseTwoInstance(backRepo, visualcenterDB)
	}
	return
}

// BackRepoVisualCenter.CheckoutPhaseTwoInstance Checkouts staged instances of VisualCenter to the BackRepo
// Phase Two is the update of instance with the field in the database
func (backRepoVisualCenter *BackRepoVisualCenterStruct) CheckoutPhaseTwoInstance(backRepo *BackRepoStruct, visualcenterDB *VisualCenterDB) (Error error) {

	visualcenter := (*backRepoVisualCenter.Map_VisualCenterDBID_VisualCenterPtr)[visualcenterDB.ID]
	_ = visualcenter // sometimes, there is no code generated. This lines voids the "unused variable" compilation error
	{
		{
			// insertion point for checkout, i.e. update of fields of stage instance from fields of back repo instances
			//
			visualcenter.Lat = visualcenterDB.Lat_Data.Float64

			visualcenter.Lng = visualcenterDB.Lng_Data.Float64

			visualcenter.Name = visualcenterDB.Name_Data.String

			visualcenter.VisualColorEnum = models.VisualColorEnum(visualcenterDB.VisualColorEnum_Data.String)

			// VisualLayer field
			if visualcenterDB.VisualLayerID.Int64 != 0 {
				visualcenter.VisualLayer = (*backRepo.BackRepoVisualLayer.Map_VisualLayerDBID_VisualLayerPtr)[uint(visualcenterDB.VisualLayerID.Int64)]
			}

			// VisualIcon field
			if visualcenterDB.VisualIconID.Int64 != 0 {
				visualcenter.VisualIcon = (*backRepo.BackRepoVisualIcon.Map_VisualIconDBID_VisualIconPtr)[uint(visualcenterDB.VisualIconID.Int64)]
			}

		}
	}
	return
}

// CommitVisualCenter allows commit of a single visualcenter (if already staged)
func (backRepo *BackRepoStruct) CommitVisualCenter(visualcenter *models.VisualCenter) {
	backRepo.BackRepoVisualCenter.CommitPhaseOneInstance(visualcenter)
	if id, ok := (*backRepo.BackRepoVisualCenter.Map_VisualCenterPtr_VisualCenterDBID)[visualcenter]; ok {
		backRepo.BackRepoVisualCenter.CommitPhaseTwoInstance(backRepo, id, visualcenter)
	}
}

// CommitVisualCenter allows checkout of a single visualcenter (if already staged and with a BackRepo id)
func (backRepo *BackRepoStruct) CheckoutVisualCenter(visualcenter *models.VisualCenter) {
	// check if the visualcenter is staged
	if _, ok := (*backRepo.BackRepoVisualCenter.Map_VisualCenterPtr_VisualCenterDBID)[visualcenter]; ok {

		if id, ok := (*backRepo.BackRepoVisualCenter.Map_VisualCenterPtr_VisualCenterDBID)[visualcenter]; ok {
			var visualcenterDB VisualCenterDB
			visualcenterDB.ID = id

			if err := backRepo.BackRepoVisualCenter.db.First(&visualcenterDB, id).Error; err != nil {
				log.Panicln("CheckoutVisualCenter : Problem with getting object with id:", id)
			}
			backRepo.BackRepoVisualCenter.CheckoutPhaseOneInstance(&visualcenterDB)
			backRepo.BackRepoVisualCenter.CheckoutPhaseTwoInstance(backRepo, &visualcenterDB)
		}
	}
}
